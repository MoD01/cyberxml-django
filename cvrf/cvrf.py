#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Wed Dec 31 18:45:04 2014 by generateDS.py version 2.14a.
#
# Command line options:
#   ('-o', 'cvrf.py')
#   ('-s', 'cvrfsubs.py')
#
# Command line arguments:
#   ./schemata/cvrf/1.1/cvrf.xsd
#
# Command line:
#   /home/action/.parts/packages/python2/2.7.6/bin/generateDS.py -o "cvrf.py" -s "cvrfsubs.py" ./schemata/cvrf/1.1/cvrf.xsd
#
# Current working directory (os.getcwd()):
#   tmp
#

import sys
import re as re_
import base64
import datetime as datetime_
import warnings as warnings_

Validate_simpletypes_ = True


etree_ = None
Verbose_import_ = False
(
    XMLParser_import_none, XMLParser_import_lxml,
    XMLParser_import_elementtree
) = range(3)
XMLParser_import_library = None
try:
    # lxml
    from lxml import etree as etree_
    XMLParser_import_library = XMLParser_import_lxml
    if Verbose_import_:
        print("running with lxml.etree")
except ImportError:
    try:
        # cElementTree from Python 2.5+
        import xml.etree.cElementTree as etree_
        XMLParser_import_library = XMLParser_import_elementtree
        if Verbose_import_:
            print("running with cElementTree on Python 2.5+")
    except ImportError:
        try:
            # ElementTree from Python 2.5+
            import xml.etree.ElementTree as etree_
            XMLParser_import_library = XMLParser_import_elementtree
            if Verbose_import_:
                print("running with ElementTree on Python 2.5+")
        except ImportError:
            try:
                # normal cElementTree install
                import cElementTree as etree_
                XMLParser_import_library = XMLParser_import_elementtree
                if Verbose_import_:
                    print("running with cElementTree")
            except ImportError:
                try:
                    # normal ElementTree install
                    import elementtree.ElementTree as etree_
                    XMLParser_import_library = XMLParser_import_elementtree
                    if Verbose_import_:
                        print("running with ElementTree")
                except ImportError:
                    raise ImportError(
                        "Failed to import ElementTree from any known place")


def parsexml_(*args, **kwargs):
    if (XMLParser_import_library == XMLParser_import_lxml and
            'parser' not in kwargs):
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        kwargs['parser'] = etree_.ETCompatXMLParser()
    doc = etree_.parse(*args, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError, exp:

    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (time_parts[0], micro_seconds, )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.  We should:
            # - AND the outer elements
            # - OR the inner elements
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    if re_.search(patterns2, target) is not None:
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.iteritems()))


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'utf-8'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    if not inStr:
        return ''
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    if XMLParser_import_library == XMLParser_import_lxml:
        msg = '%s (element %s/line %d)' % (
            msg, node.tag, node.sourceline, )
    else:
        msg = '%s (element %s)' % (msg, node.tag, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace, pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace, name, pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name, base64.b64encode(self.value), self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class cvrfdoc(GeneratedsSuper):
    """Root element of a CVRF document.This is to ensure that each
    Vulnerability's Ordinal uses a unique value.This is to ensure
    that each note has a unique ordinal value.A key to reference a
    specific product defined in a referenced product schema.An
    instance of the ProductKey to be used in the ProductID element
    for affected products.An instance of the ProductKey to be used
    in the CVSS ScoreSet product references.An instance of the
    ProductKey to be used in the Threat product references.An
    instance of the ProductKey to be used in the Remediation product
    references.A key to reference a specific product group defined
    in a referenced product schema.An instance of the GroupKey to be
    used in the Threat product references.An instance of the
    GroupKey to be used in the Remediation product references."""
    subclass = None
    superclass = None
    def __init__(self, DocumentTitle=None, DocumentType=None, DocumentPublisher=None, DocumentTracking=None, DocumentNotes=None, DocumentDistribution=None, AggregateSeverity=None, DocumentReferences=None, Acknowledgments=None, ProductTree=None, Vulnerability=None):
        self.original_tagname_ = None
        self.DocumentTitle = DocumentTitle
        self.DocumentType = DocumentType
        self.DocumentPublisher = DocumentPublisher
        self.DocumentTracking = DocumentTracking
        self.DocumentNotes = DocumentNotes
        self.DocumentDistribution = DocumentDistribution
        self.AggregateSeverity = AggregateSeverity
        self.DocumentReferences = DocumentReferences
        self.Acknowledgments = Acknowledgments
        self.ProductTree = ProductTree
        if Vulnerability is None:
            self.Vulnerability = []
        else:
            self.Vulnerability = Vulnerability
    def factory(*args_, **kwargs_):
        if cvrfdoc.subclass:
            return cvrfdoc.subclass(*args_, **kwargs_)
        else:
            return cvrfdoc(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DocumentTitle(self): return self.DocumentTitle
    def set_DocumentTitle(self, DocumentTitle): self.DocumentTitle = DocumentTitle
    def get_DocumentType(self): return self.DocumentType
    def set_DocumentType(self, DocumentType): self.DocumentType = DocumentType
    def get_DocumentPublisher(self): return self.DocumentPublisher
    def set_DocumentPublisher(self, DocumentPublisher): self.DocumentPublisher = DocumentPublisher
    def get_DocumentTracking(self): return self.DocumentTracking
    def set_DocumentTracking(self, DocumentTracking): self.DocumentTracking = DocumentTracking
    def get_DocumentNotes(self): return self.DocumentNotes
    def set_DocumentNotes(self, DocumentNotes): self.DocumentNotes = DocumentNotes
    def get_DocumentDistribution(self): return self.DocumentDistribution
    def set_DocumentDistribution(self, DocumentDistribution): self.DocumentDistribution = DocumentDistribution
    def get_AggregateSeverity(self): return self.AggregateSeverity
    def set_AggregateSeverity(self, AggregateSeverity): self.AggregateSeverity = AggregateSeverity
    def get_DocumentReferences(self): return self.DocumentReferences
    def set_DocumentReferences(self, DocumentReferences): self.DocumentReferences = DocumentReferences
    def get_Acknowledgments(self): return self.Acknowledgments
    def set_Acknowledgments(self, Acknowledgments): self.Acknowledgments = Acknowledgments
    def get_ProductTree(self): return self.ProductTree
    def set_ProductTree(self, ProductTree): self.ProductTree = ProductTree
    def get_Vulnerability(self): return self.Vulnerability
    def set_Vulnerability(self, Vulnerability): self.Vulnerability = Vulnerability
    def add_Vulnerability(self, value): self.Vulnerability.append(value)
    def insert_Vulnerability_at(self, index, value): self.Vulnerability.insert(index, value)
    def replace_Vulnerability_at(self, index, value): self.Vulnerability[index] = value
    def hasContent_(self):
        if (
            self.DocumentTitle is not None or
            self.DocumentType is not None or
            self.DocumentPublisher is not None or
            self.DocumentTracking is not None or
            self.DocumentNotes is not None or
            self.DocumentDistribution is not None or
            self.AggregateSeverity is not None or
            self.DocumentReferences is not None or
            self.Acknowledgments is not None or
            self.ProductTree is not None or
            self.Vulnerability
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='cvrfdoc', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1" xmlns:prod="http://www.icasi.org/CVRF/schema/prod/1.1"  xmlns:vuln="http://www.icasi.org/CVRF/schema/vuln/1.1" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cvrfdoc')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='cvrfdoc', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='cvrfdoc'):
        pass
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='cvrfdoc', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DocumentTitle is not None:
            self.DocumentTitle.export(outfile, level, namespace_, name_='DocumentTitle', pretty_print=pretty_print)
        if self.DocumentType is not None:
            self.DocumentType.export(outfile, level, namespace_, name_='DocumentType', pretty_print=pretty_print)
        if self.DocumentPublisher is not None:
            self.DocumentPublisher.export(outfile, level, namespace_, name_='DocumentPublisher', pretty_print=pretty_print)
        if self.DocumentTracking is not None:
            self.DocumentTracking.export(outfile, level, namespace_, name_='DocumentTracking', pretty_print=pretty_print)
        if self.DocumentNotes is not None:
            self.DocumentNotes.export(outfile, level, namespace_, name_='DocumentNotes', pretty_print=pretty_print)
        if self.DocumentDistribution is not None:
            self.DocumentDistribution.export(outfile, level, namespace_, name_='DocumentDistribution', pretty_print=pretty_print)
        if self.AggregateSeverity is not None:
            self.AggregateSeverity.export(outfile, level, namespace_, name_='AggregateSeverity', pretty_print=pretty_print)
        if self.DocumentReferences is not None:
            self.DocumentReferences.export(outfile, level, namespace_, name_='DocumentReferences', pretty_print=pretty_print)
        if self.Acknowledgments is not None:
            self.Acknowledgments.export(outfile, level, namespace_, name_='Acknowledgments', pretty_print=pretty_print)
        if self.ProductTree is not None:
            self.ProductTree.export(outfile, level, namespace_='prod:', name_='ProductTree', pretty_print=pretty_print)
        for Vulnerability_ in self.Vulnerability:
            Vulnerability_.export(outfile, level, namespace_='vuln:', name_='Vulnerability', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='cvrfdoc'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.DocumentTitle is not None:
            showIndent(outfile, level)
            outfile.write('DocumentTitle=model_.DocumentTitleType(\n')
            self.DocumentTitle.exportLiteral(outfile, level, name_='DocumentTitle')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DocumentType is not None:
            showIndent(outfile, level)
            outfile.write('DocumentType=model_.DocumentTypeType(\n')
            self.DocumentType.exportLiteral(outfile, level, name_='DocumentType')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DocumentPublisher is not None:
            showIndent(outfile, level)
            outfile.write('DocumentPublisher=model_.DocumentPublisherType(\n')
            self.DocumentPublisher.exportLiteral(outfile, level, name_='DocumentPublisher')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DocumentTracking is not None:
            showIndent(outfile, level)
            outfile.write('DocumentTracking=model_.DocumentTrackingType(\n')
            self.DocumentTracking.exportLiteral(outfile, level, name_='DocumentTracking')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DocumentNotes is not None:
            showIndent(outfile, level)
            outfile.write('DocumentNotes=model_.DocumentNotesType(\n')
            self.DocumentNotes.exportLiteral(outfile, level, name_='DocumentNotes')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DocumentDistribution is not None:
            showIndent(outfile, level)
            outfile.write('DocumentDistribution=model_.DocumentDistributionType(\n')
            self.DocumentDistribution.exportLiteral(outfile, level, name_='DocumentDistribution')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.AggregateSeverity is not None:
            showIndent(outfile, level)
            outfile.write('AggregateSeverity=model_.AggregateSeverityType(\n')
            self.AggregateSeverity.exportLiteral(outfile, level, name_='AggregateSeverity')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DocumentReferences is not None:
            showIndent(outfile, level)
            outfile.write('DocumentReferences=model_.DocumentReferencesType(\n')
            self.DocumentReferences.exportLiteral(outfile, level, name_='DocumentReferences')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Acknowledgments is not None:
            showIndent(outfile, level)
            outfile.write('Acknowledgments=model_.AcknowledgmentsType(\n')
            self.Acknowledgments.exportLiteral(outfile, level, name_='Acknowledgments')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ProductTree is not None:
            showIndent(outfile, level)
            outfile.write('ProductTree=model_.ProductTree(\n')
            self.ProductTree.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Vulnerability=[\n')
        level += 1
        for Vulnerability_ in self.Vulnerability:
            showIndent(outfile, level)
            outfile.write('model_.Vulnerability(\n')
            Vulnerability_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DocumentTitle':
            obj_ = DocumentTitleType.factory()
            obj_.build(child_)
            self.DocumentTitle = obj_
            obj_.original_tagname_ = 'DocumentTitle'
        elif nodeName_ == 'DocumentType':
            obj_ = DocumentTypeType.factory()
            obj_.build(child_)
            self.DocumentType = obj_
            obj_.original_tagname_ = 'DocumentType'
        elif nodeName_ == 'DocumentPublisher':
            obj_ = DocumentPublisherType.factory()
            obj_.build(child_)
            self.DocumentPublisher = obj_
            obj_.original_tagname_ = 'DocumentPublisher'
        elif nodeName_ == 'DocumentTracking':
            obj_ = DocumentTrackingType.factory()
            obj_.build(child_)
            self.DocumentTracking = obj_
            obj_.original_tagname_ = 'DocumentTracking'
        elif nodeName_ == 'DocumentNotes':
            obj_ = DocumentNotesType.factory()
            obj_.build(child_)
            self.DocumentNotes = obj_
            obj_.original_tagname_ = 'DocumentNotes'
        elif nodeName_ == 'DocumentDistribution':
            obj_ = DocumentDistributionType.factory()
            obj_.build(child_)
            self.DocumentDistribution = obj_
            obj_.original_tagname_ = 'DocumentDistribution'
        elif nodeName_ == 'AggregateSeverity':
            obj_ = AggregateSeverityType.factory()
            obj_.build(child_)
            self.AggregateSeverity = obj_
            obj_.original_tagname_ = 'AggregateSeverity'
        elif nodeName_ == 'DocumentReferences':
            obj_ = DocumentReferencesType.factory()
            obj_.build(child_)
            self.DocumentReferences = obj_
            obj_.original_tagname_ = 'DocumentReferences'
        elif nodeName_ == 'Acknowledgments':
            obj_ = AcknowledgmentsType.factory()
            obj_.build(child_)
            self.Acknowledgments = obj_
            obj_.original_tagname_ = 'Acknowledgments'
        elif nodeName_ == 'ProductTree':
            obj_ = ProductTree.factory()
            obj_.build(child_)
            self.ProductTree = obj_
            obj_.original_tagname_ = 'ProductTree'
        elif nodeName_ == 'Vulnerability':
            obj_ = Vulnerability.factory()
            obj_.build(child_)
            self.Vulnerability.append(obj_)
            obj_.original_tagname_ = 'Vulnerability'
# end class cvrfdoc


class SimpleLiteral(GeneratedsSuper):
    """This is the default type for all of the DC elements. It permits text
    content only with optional xml:lang attribute. Text is allowed
    because mixed="true", but sub-elements are disallowed because
    minOccurs="0" and maxOccurs="0" are on the xs:any tag. This
    complexType allows for restriction or extension permitting child
    elements."""
    subclass = None
    superclass = None
    def __init__(self, lang=None, anytypeobjs_=None):
        self.original_tagname_ = None
        self.lang = _cast(None, lang)
        self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if SimpleLiteral.subclass:
            return SimpleLiteral.subclass(*args_, **kwargs_)
        else:
            return SimpleLiteral(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def get_lang(self): return self.lang
    def set_lang(self, lang): self.lang = lang
    def hasContent_(self):
        if (
            self.anytypeobjs_ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='SimpleLiteral', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SimpleLiteral')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='SimpleLiteral', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='SimpleLiteral'):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' lang=%s' % (self.gds_format_string(quote_attrib(self.lang).encode(ExternalEncoding), input_name='lang'), ))
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='SimpleLiteral', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.anytypeobjs_ is not None:
            self.anytypeobjs_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='SimpleLiteral'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            showIndent(outfile, level)
            outfile.write('lang="%s",\n' % (self.lang,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.anytypeobjs_ is not None:
            showIndent(outfile, level)
            outfile.write('anytypeobjs_=model_.anytypeobjs_(\n')
            self.anytypeobjs_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        obj_ = self.gds_build_any(child_, 'SimpleLiteral')
        if obj_ is not None:
            self.set_anytypeobjs_(obj_)
# end class SimpleLiteral


class title(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if title.subclass:
            return title.subclass(*args_, **kwargs_)
        else:
            return title(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='title', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='title')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='title', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='title'):
        pass
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='title', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='title'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class title


class creator(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if creator.subclass:
            return creator.subclass(*args_, **kwargs_)
        else:
            return creator(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='creator', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='creator')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='creator', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='creator'):
        pass
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='creator', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='creator'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class creator


class subject(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if subject.subclass:
            return subject.subclass(*args_, **kwargs_)
        else:
            return subject(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='subject', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='subject')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='subject', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='subject'):
        pass
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='subject', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='subject'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class subject


class description(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if description.subclass:
            return description.subclass(*args_, **kwargs_)
        else:
            return description(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='description', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='description')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='description', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='description'):
        pass
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='description', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='description'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class description


class publisher(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if publisher.subclass:
            return publisher.subclass(*args_, **kwargs_)
        else:
            return publisher(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='publisher', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='publisher')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='publisher', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='publisher'):
        pass
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='publisher', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='publisher'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class publisher


class contributor(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if contributor.subclass:
            return contributor.subclass(*args_, **kwargs_)
        else:
            return contributor(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='contributor', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='contributor')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='contributor', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='contributor'):
        pass
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='contributor', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='contributor'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class contributor


class date(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if date.subclass:
            return date.subclass(*args_, **kwargs_)
        else:
            return date(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='date', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='date')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='date', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='date'):
        pass
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='date', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='date'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class date


class type_(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if type_.subclass:
            return type_.subclass(*args_, **kwargs_)
        else:
            return type_(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='type', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='type'):
        pass
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='type', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class type_


class format(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if format.subclass:
            return format.subclass(*args_, **kwargs_)
        else:
            return format(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='format', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='format')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='format', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='format'):
        pass
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='format', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='format'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class format


class identifier(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if identifier.subclass:
            return identifier.subclass(*args_, **kwargs_)
        else:
            return identifier(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='identifier', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='identifier')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='identifier', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='identifier'):
        pass
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='identifier', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='identifier'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class identifier


class source(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if source.subclass:
            return source.subclass(*args_, **kwargs_)
        else:
            return source(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='source', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='source')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='source', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='source'):
        pass
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='source', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='source'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class source


class language(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if language.subclass:
            return language.subclass(*args_, **kwargs_)
        else:
            return language(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='language', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='language')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='language', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='language'):
        pass
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='language', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='language'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class language


class relation(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if relation.subclass:
            return relation.subclass(*args_, **kwargs_)
        else:
            return relation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='relation', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='relation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='relation', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='relation'):
        pass
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='relation', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='relation'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class relation


class coverage(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if coverage.subclass:
            return coverage.subclass(*args_, **kwargs_)
        else:
            return coverage(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='coverage', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='coverage')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='coverage', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='coverage'):
        pass
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='coverage', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='coverage'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class coverage


class rights(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if rights.subclass:
            return rights.subclass(*args_, **kwargs_)
        else:
            return rights(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='rights', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='rights')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='rights', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='rights'):
        pass
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='rights', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='rights'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class rights


class elementContainer(GeneratedsSuper):
    """This complexType is included as a convenience for schema authors who
    need to define a root or container element for all of the DC
    elements."""
    subclass = None
    superclass = None
    def __init__(self, any=None):
        self.original_tagname_ = None
        if any is None:
            self.any = []
        else:
            self.any = any
    def factory(*args_, **kwargs_):
        if elementContainer.subclass:
            return elementContainer.subclass(*args_, **kwargs_)
        else:
            return elementContainer(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_any(self): return self.any
    def set_any(self, any): self.any = any
    def add_any(self, value): self.any.append(value)
    def insert_any_at(self, index, value): self.any.insert(index, value)
    def replace_any_at(self, index, value): self.any[index] = value
    def hasContent_(self):
        if (
            self.any
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='elementContainer', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='elementContainer')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='elementContainer', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='elementContainer'):
        pass
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='elementContainer', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for any_ in self.any:
            any_.export(outfile, level, namespace_, name_='any', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='elementContainer'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('any=[\n')
        level += 1
        for any_ in self.any:
            showIndent(outfile, level)
            outfile.write('model_.any(\n')
            any_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'any':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <any> element')
            self.any.append(obj_)
            obj_.original_tagname_ = 'any'
        elif nodeName_ == 'title':
            obj_ = title.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'title'
        elif nodeName_ == 'creator':
            obj_ = creator.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'creator'
        elif nodeName_ == 'subject':
            obj_ = subject.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'subject'
        elif nodeName_ == 'description':
            obj_ = description.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'description'
        elif nodeName_ == 'publisher':
            obj_ = publisher.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'publisher'
        elif nodeName_ == 'contributor':
            obj_ = contributor.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'contributor'
        elif nodeName_ == 'date':
            obj_ = date.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'date'
        elif nodeName_ == 'type':
            obj_ = type_.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'type'
        elif nodeName_ == 'format':
            obj_ = format.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'format'
        elif nodeName_ == 'identifier':
            obj_ = identifier.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'identifier'
        elif nodeName_ == 'source':
            obj_ = source.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'source'
        elif nodeName_ == 'language':
            obj_ = language.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'language'
        elif nodeName_ == 'relation':
            obj_ = relation.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'relation'
        elif nodeName_ == 'coverage':
            obj_ = coverage.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'coverage'
        elif nodeName_ == 'rights':
            obj_ = rights.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'rights'
# end class elementContainer


class Vulnerability(GeneratedsSuper):
    """This is a meta-container for the aggregation of all fields that are
    related to a single vulnerability within the document.Locally
    significant numeric value to track vulnerabilities within a CVRF
    document. This enables vulnerabilities to be referenced from
    elsewhere inside the document (often at the document-level)This
    is to ensure that each product mentions a given ProductID only
    one.This is to ensure that each CVSS score set mentions a given
    ProductID only one.This is to ensure that each note has a unique
    ordinal value."""
    subclass = None
    superclass = None
    def __init__(self, Ordinal=None, Title=None, ID=None, Notes=None, DiscoveryDate=None, ReleaseDate=None, Involvements=None, CVE=None, CWE=None, ProductStatuses=None, Threats=None, CVSSScoreSets=None, Remediations=None, References=None, Acknowledgments=None):
        self.original_tagname_ = None
        self.Ordinal = _cast(int, Ordinal)
        self.Title = Title
        self.ID = ID
        self.Notes = Notes
        if isinstance(DiscoveryDate, basestring):
            initvalue_ = datetime_.datetime.strptime(DiscoveryDate, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = DiscoveryDate
        self.DiscoveryDate = initvalue_
        if isinstance(ReleaseDate, basestring):
            initvalue_ = datetime_.datetime.strptime(ReleaseDate, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = ReleaseDate
        self.ReleaseDate = initvalue_
        self.Involvements = Involvements
        self.CVE = CVE
        self.validate_cvePattern(self.CVE)
        if CWE is None:
            self.CWE = []
        else:
            self.CWE = CWE
        self.ProductStatuses = ProductStatuses
        self.Threats = Threats
        self.CVSSScoreSets = CVSSScoreSets
        self.Remediations = Remediations
        self.References = References
        self.Acknowledgments = Acknowledgments
    def factory(*args_, **kwargs_):
        if Vulnerability.subclass:
            return Vulnerability.subclass(*args_, **kwargs_)
        else:
            return Vulnerability(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Title(self): return self.Title
    def set_Title(self, Title): self.Title = Title
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_Notes(self): return self.Notes
    def set_Notes(self, Notes): self.Notes = Notes
    def get_DiscoveryDate(self): return self.DiscoveryDate
    def set_DiscoveryDate(self, DiscoveryDate): self.DiscoveryDate = DiscoveryDate
    def get_ReleaseDate(self): return self.ReleaseDate
    def set_ReleaseDate(self, ReleaseDate): self.ReleaseDate = ReleaseDate
    def get_Involvements(self): return self.Involvements
    def set_Involvements(self, Involvements): self.Involvements = Involvements
    def get_CVE(self): return self.CVE
    def set_CVE(self, CVE): self.CVE = CVE
    def get_CWE(self): return self.CWE
    def set_CWE(self, CWE): self.CWE = CWE
    def add_CWE(self, value): self.CWE.append(value)
    def insert_CWE_at(self, index, value): self.CWE.insert(index, value)
    def replace_CWE_at(self, index, value): self.CWE[index] = value
    def get_ProductStatuses(self): return self.ProductStatuses
    def set_ProductStatuses(self, ProductStatuses): self.ProductStatuses = ProductStatuses
    def get_Threats(self): return self.Threats
    def set_Threats(self, Threats): self.Threats = Threats
    def get_CVSSScoreSets(self): return self.CVSSScoreSets
    def set_CVSSScoreSets(self, CVSSScoreSets): self.CVSSScoreSets = CVSSScoreSets
    def get_Remediations(self): return self.Remediations
    def set_Remediations(self, Remediations): self.Remediations = Remediations
    def get_References(self): return self.References
    def set_References(self, References): self.References = References
    def get_Acknowledgments(self): return self.Acknowledgments
    def set_Acknowledgments(self, Acknowledgments): self.Acknowledgments = Acknowledgments
    def get_Ordinal(self): return self.Ordinal
    def set_Ordinal(self, Ordinal): self.Ordinal = Ordinal
    def validate_cvePattern(self, value):
        # Validate type cvePattern, a restriction on xs:token.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_cvePattern_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cvePattern_patterns_, ))
    validate_cvePattern_patterns_ = [['^CVE-[0-9\\-]+$']]
    def hasContent_(self):
        if (
            self.Title is not None or
            self.ID is not None or
            self.Notes is not None or
            self.DiscoveryDate is not None or
            self.ReleaseDate is not None or
            self.Involvements is not None or
            self.CVE is not None or
            self.CWE or
            self.ProductStatuses is not None or
            self.Threats is not None or
            self.CVSSScoreSets is not None or
            self.Remediations is not None or
            self.References is not None or
            self.Acknowledgments is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='Vulnerability', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1" xmlns:vuln="http://www.icasi.org/CVRF/schema/vuln/1.1" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Vulnerability')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='Vulnerability', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='Vulnerability'):
        if self.Ordinal is not None and 'Ordinal' not in already_processed:
            already_processed.add('Ordinal')
            outfile.write(' Ordinal="%s"' % self.gds_format_integer(self.Ordinal, input_name='Ordinal'))
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='Vulnerability', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Title is not None:
            self.Title.export(outfile, level, namespace_, name_='Title', pretty_print=pretty_print)
        if self.ID is not None:
            self.ID.export(outfile, level, namespace_, name_='ID', pretty_print=pretty_print)
        if self.Notes is not None:
            self.Notes.export(outfile, level, namespace_, name_='Notes', pretty_print=pretty_print)
        if self.DiscoveryDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDiscoveryDate>%s</%sDiscoveryDate>%s' % (namespace_, self.gds_format_datetime(self.DiscoveryDate, input_name='DiscoveryDate'), namespace_, eol_))
        if self.ReleaseDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sReleaseDate>%s</%sReleaseDate>%s' % (namespace_, self.gds_format_datetime(self.ReleaseDate, input_name='ReleaseDate'), namespace_, eol_))
        if self.Involvements is not None:
            self.Involvements.export(outfile, level, namespace_, name_='Involvements', pretty_print=pretty_print)
        if self.CVE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCVE>%s</%sCVE>%s' % (namespace_, self.gds_format_string(quote_xml(self.CVE).encode(ExternalEncoding), input_name='CVE'), namespace_, eol_))
        for CWE_ in self.CWE:
            CWE_.export(outfile, level, namespace_, name_='CWE', pretty_print=pretty_print)
        if self.ProductStatuses is not None:
            self.ProductStatuses.export(outfile, level, namespace_, name_='ProductStatuses', pretty_print=pretty_print)
        if self.Threats is not None:
            self.Threats.export(outfile, level, namespace_, name_='Threats', pretty_print=pretty_print)
        if self.CVSSScoreSets is not None:
            self.CVSSScoreSets.export(outfile, level, namespace_, name_='CVSSScoreSets', pretty_print=pretty_print)
        if self.Remediations is not None:
            self.Remediations.export(outfile, level, namespace_, name_='Remediations', pretty_print=pretty_print)
        if self.References is not None:
            self.References.export(outfile, level, namespace_, name_='References', pretty_print=pretty_print)
        if self.Acknowledgments is not None:
            self.Acknowledgments.export(outfile, level, namespace_, name_='Acknowledgments', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='Vulnerability'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Ordinal is not None and 'Ordinal' not in already_processed:
            already_processed.add('Ordinal')
            showIndent(outfile, level)
            outfile.write('Ordinal=%d,\n' % (self.Ordinal,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Title is not None:
            showIndent(outfile, level)
            outfile.write('Title=model_.TitleType(\n')
            self.Title.exportLiteral(outfile, level, name_='Title')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ID is not None:
            showIndent(outfile, level)
            outfile.write('ID=model_.IDType3(\n')
            self.ID.exportLiteral(outfile, level, name_='ID')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Notes is not None:
            showIndent(outfile, level)
            outfile.write('Notes=model_.NotesType(\n')
            self.Notes.exportLiteral(outfile, level, name_='Notes')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DiscoveryDate is not None:
            showIndent(outfile, level)
            outfile.write('DiscoveryDate=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.DiscoveryDate, input_name='DiscoveryDate'))
        if self.ReleaseDate is not None:
            showIndent(outfile, level)
            outfile.write('ReleaseDate=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.ReleaseDate, input_name='ReleaseDate'))
        if self.Involvements is not None:
            showIndent(outfile, level)
            outfile.write('Involvements=model_.InvolvementsType(\n')
            self.Involvements.exportLiteral(outfile, level, name_='Involvements')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CVE is not None:
            showIndent(outfile, level)
            outfile.write('CVE=%s,\n' % quote_python(self.CVE).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('CWE=[\n')
        level += 1
        for CWE_ in self.CWE:
            showIndent(outfile, level)
            outfile.write('model_.CWEType(\n')
            CWE_.exportLiteral(outfile, level, name_='CWEType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.ProductStatuses is not None:
            showIndent(outfile, level)
            outfile.write('ProductStatuses=model_.ProductStatusesType(\n')
            self.ProductStatuses.exportLiteral(outfile, level, name_='ProductStatuses')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Threats is not None:
            showIndent(outfile, level)
            outfile.write('Threats=model_.ThreatsType(\n')
            self.Threats.exportLiteral(outfile, level, name_='Threats')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CVSSScoreSets is not None:
            showIndent(outfile, level)
            outfile.write('CVSSScoreSets=model_.CVSSScoreSetsType(\n')
            self.CVSSScoreSets.exportLiteral(outfile, level, name_='CVSSScoreSets')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Remediations is not None:
            showIndent(outfile, level)
            outfile.write('Remediations=model_.RemediationsType(\n')
            self.Remediations.exportLiteral(outfile, level, name_='Remediations')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.References is not None:
            showIndent(outfile, level)
            outfile.write('References=model_.ReferencesType(\n')
            self.References.exportLiteral(outfile, level, name_='References')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Acknowledgments is not None:
            showIndent(outfile, level)
            outfile.write('Acknowledgments=model_.AcknowledgmentsType10(\n')
            self.Acknowledgments.exportLiteral(outfile, level, name_='Acknowledgments')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Ordinal', node)
        if value is not None and 'Ordinal' not in already_processed:
            already_processed.add('Ordinal')
            try:
                self.Ordinal = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.Ordinal <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Title':
            obj_ = TitleType.factory()
            obj_.build(child_)
            self.Title = obj_
            obj_.original_tagname_ = 'Title'
        elif nodeName_ == 'ID':
            obj_ = IDType3.factory()
            obj_.build(child_)
            self.ID = obj_
            obj_.original_tagname_ = 'ID'
        elif nodeName_ == 'Notes':
            obj_ = NotesType.factory()
            obj_.build(child_)
            self.Notes = obj_
            obj_.original_tagname_ = 'Notes'
        elif nodeName_ == 'DiscoveryDate':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.DiscoveryDate = dval_
        elif nodeName_ == 'ReleaseDate':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.ReleaseDate = dval_
        elif nodeName_ == 'Involvements':
            obj_ = InvolvementsType.factory()
            obj_.build(child_)
            self.Involvements = obj_
            obj_.original_tagname_ = 'Involvements'
        elif nodeName_ == 'CVE':
            CVE_ = child_.text
            CVE_ = re_.sub(String_cleanup_pat_, " ", CVE_).strip()
            CVE_ = self.gds_validate_string(CVE_, node, 'CVE')
            self.CVE = CVE_
            self.validate_cvePattern(self.CVE)    # validate type cvePattern
        elif nodeName_ == 'CWE':
            obj_ = CWEType.factory()
            obj_.build(child_)
            self.CWE.append(obj_)
            obj_.original_tagname_ = 'CWE'
        elif nodeName_ == 'ProductStatuses':
            obj_ = ProductStatusesType.factory()
            obj_.build(child_)
            self.ProductStatuses = obj_
            obj_.original_tagname_ = 'ProductStatuses'
        elif nodeName_ == 'Threats':
            obj_ = ThreatsType.factory()
            obj_.build(child_)
            self.Threats = obj_
            obj_.original_tagname_ = 'Threats'
        elif nodeName_ == 'CVSSScoreSets':
            obj_ = CVSSScoreSetsType.factory()
            obj_.build(child_)
            self.CVSSScoreSets = obj_
            obj_.original_tagname_ = 'CVSSScoreSets'
        elif nodeName_ == 'Remediations':
            obj_ = RemediationsType.factory()
            obj_.build(child_)
            self.Remediations = obj_
            obj_.original_tagname_ = 'Remediations'
        elif nodeName_ == 'References':
            obj_ = ReferencesType.factory()
            obj_.build(child_)
            self.References = obj_
            obj_.original_tagname_ = 'References'
        elif nodeName_ == 'Acknowledgments':
            obj_ = AcknowledgmentsType10.factory()
            obj_.build(child_)
            self.Acknowledgments = obj_
            obj_.original_tagname_ = 'Acknowledgments'
# end class Vulnerability


class platformSpecificationType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, platform=None):
        self.original_tagname_ = None
        if platform is None:
            self.platform = []
        else:
            self.platform = platform
    def factory(*args_, **kwargs_):
        if platformSpecificationType.subclass:
            return platformSpecificationType.subclass(*args_, **kwargs_)
        else:
            return platformSpecificationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_platform(self): return self.platform
    def set_platform(self, platform): self.platform = platform
    def add_platform(self, value): self.platform.append(value)
    def insert_platform_at(self, index, value): self.platform.insert(index, value)
    def replace_platform_at(self, index, value): self.platform[index] = value
    def hasContent_(self):
        if (
            self.platform
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='platformSpecificationType', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='platformSpecificationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='platformSpecificationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='platformSpecificationType'):
        pass
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='platformSpecificationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for platform_ in self.platform:
            platform_.export(outfile, level, namespace_='cpe:', name_='platform', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='platformSpecificationType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('platform=[\n')
        level += 1
        for platform_ in self.platform:
            showIndent(outfile, level)
            outfile.write('model_.platform(\n')
            platform_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'platform':
            obj_ = PlatformType.factory()
            obj_.build(child_)
            self.platform.append(obj_)
            obj_.original_tagname_ = 'platform'
# end class platformSpecificationType


class PlatformBaseType(GeneratedsSuper):
    """The platform element represents the description or qualifications of
    a particular IT platform type. The platform is defined by the
    logical-test child element."""
    subclass = None
    superclass = None
    def __init__(self, title=None, remark=None, logical_test=None, extensiontype_=None):
        self.original_tagname_ = None
        if title is None:
            self.title = []
        else:
            self.title = title
        if remark is None:
            self.remark = []
        else:
            self.remark = remark
        self.logical_test = logical_test
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if PlatformBaseType.subclass:
            return PlatformBaseType.subclass(*args_, **kwargs_)
        else:
            return PlatformBaseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    def add_title(self, value): self.title.append(value)
    def insert_title_at(self, index, value): self.title.insert(index, value)
    def replace_title_at(self, index, value): self.title[index] = value
    def get_remark(self): return self.remark
    def set_remark(self, remark): self.remark = remark
    def add_remark(self, value): self.remark.append(value)
    def insert_remark_at(self, index, value): self.remark.insert(index, value)
    def replace_remark_at(self, index, value): self.remark[index] = value
    def get_logical_test(self): return self.logical_test
    def set_logical_test(self, logical_test): self.logical_test = logical_test
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.title or
            self.remark or
            self.logical_test is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='PlatformBaseType', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PlatformBaseType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='PlatformBaseType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='PlatformBaseType'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='PlatformBaseType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for title_ in self.title:
            title_.export(outfile, level, namespace_, name_='title', pretty_print=pretty_print)
        for remark_ in self.remark:
            remark_.export(outfile, level, namespace_, name_='remark', pretty_print=pretty_print)
        if self.logical_test is not None:
            self.logical_test.export(outfile, level, namespace_='cpe:', name_='logical-test', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='PlatformBaseType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('title=[\n')
        level += 1
        for title_ in self.title:
            showIndent(outfile, level)
            outfile.write('model_.TextType(\n')
            title_.exportLiteral(outfile, level, name_='TextType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('remark=[\n')
        level += 1
        for remark_ in self.remark:
            showIndent(outfile, level)
            outfile.write('model_.TextType(\n')
            remark_.exportLiteral(outfile, level, name_='TextType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.logical_test is not None:
            showIndent(outfile, level)
            outfile.write('logical_test=model_.logical_test(\n')
            self.logical_test.exportLiteral(outfile, level, name_='logical_test')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'title':
            obj_ = TextType.factory()
            obj_.build(child_)
            self.title.append(obj_)
            obj_.original_tagname_ = 'title'
        elif nodeName_ == 'remark':
            obj_ = TextType.factory()
            obj_.build(child_)
            self.remark.append(obj_)
            obj_.original_tagname_ = 'remark'
        elif nodeName_ == 'logical-test':
            obj_ = LogicalTestType.factory()
            obj_.build(child_)
            self.logical_test = obj_
            obj_.original_tagname_ = 'logical-test'
# end class PlatformBaseType


class PlatformType(PlatformBaseType):
    """The id attribute holds a locally unique name for the platform. There
    is no defined format for this id, it just has to be unique to
    the containing language document."""
    subclass = None
    superclass = PlatformBaseType
    def __init__(self, title=None, remark=None, logical_test=None, id=None):
        self.original_tagname_ = None
        super(PlatformType, self).__init__(title, remark, logical_test, )
        self.id = _cast(None, id)
    def factory(*args_, **kwargs_):
        if PlatformType.subclass:
            return PlatformType.subclass(*args_, **kwargs_)
        else:
            return PlatformType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            super(PlatformType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='PlatformType', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PlatformType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='PlatformType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='PlatformType'):
        super(PlatformType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PlatformType')
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='PlatformType', fromsubclass_=False, pretty_print=True):
        super(PlatformType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='PlatformType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id=%s,\n' % (self.id,))
        super(PlatformType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(PlatformType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        super(PlatformType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(PlatformType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class PlatformType


class LogicalTestType(GeneratedsSuper):
    """The logical-test element appears as a child of a platform element,
    and may also be nested to create more complex logical tests. The
    content consists of one or more elements: fact-ref, and logical-
    test children are permitted. The operator to be applied, and
    optional negation of the test, are given as attributes."""
    subclass = None
    superclass = None
    def __init__(self, operator=None, negate=None, logical_test=None, fact_ref=None):
        self.original_tagname_ = None
        self.operator = _cast(None, operator)
        self.negate = _cast(None, negate)
        if logical_test is None:
            self.logical_test = []
        else:
            self.logical_test = logical_test
        if fact_ref is None:
            self.fact_ref = []
        else:
            self.fact_ref = fact_ref
    def factory(*args_, **kwargs_):
        if LogicalTestType.subclass:
            return LogicalTestType.subclass(*args_, **kwargs_)
        else:
            return LogicalTestType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_logical_test(self): return self.logical_test
    def set_logical_test(self, logical_test): self.logical_test = logical_test
    def add_logical_test(self, value): self.logical_test.append(value)
    def insert_logical_test_at(self, index, value): self.logical_test.insert(index, value)
    def replace_logical_test_at(self, index, value): self.logical_test[index] = value
    def get_fact_ref(self): return self.fact_ref
    def set_fact_ref(self, fact_ref): self.fact_ref = fact_ref
    def add_fact_ref(self, value): self.fact_ref.append(value)
    def insert_fact_ref_at(self, index, value): self.fact_ref.insert(index, value)
    def replace_fact_ref_at(self, index, value): self.fact_ref[index] = value
    def get_operator(self): return self.operator
    def set_operator(self, operator): self.operator = operator
    def get_negate(self): return self.negate
    def set_negate(self, negate): self.negate = negate
    def hasContent_(self):
        if (
            self.logical_test or
            self.fact_ref
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='LogicalTestType', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LogicalTestType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='LogicalTestType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='LogicalTestType'):
        if self.operator is not None and 'operator' not in already_processed:
            already_processed.add('operator')
            outfile.write(' operator=%s' % (quote_attrib(self.operator), ))
        if self.negate is not None and 'negate' not in already_processed:
            already_processed.add('negate')
            outfile.write(' negate=%s' % (quote_attrib(self.negate), ))
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='LogicalTestType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for logical_test_ in self.logical_test:
            logical_test_.export(outfile, level, namespace_, name_='logical-test', pretty_print=pretty_print)
        for fact_ref_ in self.fact_ref:
            fact_ref_.export(outfile, level, namespace_='cpe:', name_='fact-ref', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='LogicalTestType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.operator is not None and 'operator' not in already_processed:
            already_processed.add('operator')
            showIndent(outfile, level)
            outfile.write('operator=%s,\n' % (self.operator,))
        if self.negate is not None and 'negate' not in already_processed:
            already_processed.add('negate')
            showIndent(outfile, level)
            outfile.write('negate=%s,\n' % (self.negate,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('logical_test=[\n')
        level += 1
        for logical_test_ in self.logical_test:
            showIndent(outfile, level)
            outfile.write('model_.LogicalTestType(\n')
            logical_test_.exportLiteral(outfile, level, name_='LogicalTestType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('fact_ref=[\n')
        level += 1
        for fact_ref_ in self.fact_ref:
            showIndent(outfile, level)
            outfile.write('model_.fact_ref(\n')
            fact_ref_.exportLiteral(outfile, level, name_='fact-ref')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('operator', node)
        if value is not None and 'operator' not in already_processed:
            already_processed.add('operator')
            self.operator = value
        value = find_attr_value_('negate', node)
        if value is not None and 'negate' not in already_processed:
            already_processed.add('negate')
            self.negate = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'logical-test':
            obj_ = LogicalTestType.factory()
            obj_.build(child_)
            self.logical_test.append(obj_)
            obj_.original_tagname_ = 'logical-test'
        elif nodeName_ == 'fact-ref':
            obj_ = FactRefType.factory()
            obj_.build(child_)
            self.fact_ref.append(obj_)
            obj_.original_tagname_ = 'fact-ref'
# end class LogicalTestType


class FactRefType(GeneratedsSuper):
    """The fact-ref element appears as a child of a logical-test element.
    It is simply a reference to a CPE Name that always evaluates to
    a Boolean result."""
    subclass = None
    superclass = None
    def __init__(self, name=None):
        self.original_tagname_ = None
        self.name = _cast(None, name)
    def factory(*args_, **kwargs_):
        if FactRefType.subclass:
            return FactRefType.subclass(*args_, **kwargs_)
        else:
            return FactRefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='FactRefType', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FactRefType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='FactRefType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='FactRefType'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (quote_attrib(self.name), ))
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='FactRefType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='FactRefType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class FactRefType


class TextType(GeneratedsSuper):
    """This type allows the xml:lang attribute to associate a specific
    language with an element's string content."""
    subclass = None
    superclass = None
    def __init__(self, lang=None, valueOf_=None):
        self.original_tagname_ = None
        self.lang = _cast(None, lang)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if TextType.subclass:
            return TextType.subclass(*args_, **kwargs_)
        else:
            return TextType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_lang(self): return self.lang
    def set_lang(self, lang): self.lang = lang
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='TextType', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TextType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='TextType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='TextType'):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' lang=%s' % (self.gds_format_string(quote_attrib(self.lang).encode(ExternalEncoding), input_name='lang'), ))
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='TextType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='TextType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            showIndent(outfile, level)
            outfile.write('lang="%s",\n' % (self.lang,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class TextType


class checkSearchType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, system=None, name=None, extensiontype_=None):
        self.original_tagname_ = None
        self.system = _cast(None, system)
        self.name = _cast(None, name)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if checkSearchType.subclass:
            return checkSearchType.subclass(*args_, **kwargs_)
        else:
            return checkSearchType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_system(self): return self.system
    def set_system(self, system): self.system = system
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='checkSearchType', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='checkSearchType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='checkSearchType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='checkSearchType'):
        if self.system is not None and 'system' not in already_processed:
            already_processed.add('system')
            outfile.write(' system=%s' % (quote_attrib(self.system), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (quote_attrib(self.name), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='checkSearchType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='checkSearchType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.system is not None and 'system' not in already_processed:
            already_processed.add('system')
            showIndent(outfile, level)
            outfile.write('system=%s,\n' % (self.system,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('system', node)
        if value is not None and 'system' not in already_processed:
            already_processed.add('system')
            self.system = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class checkSearchType


class searchableCpeReferencesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, cpe_name=None, cpe_searchable_name=None):
        self.original_tagname_ = None
        if cpe_name is None:
            self.cpe_name = []
        else:
            self.cpe_name = cpe_name
        if cpe_searchable_name is None:
            self.cpe_searchable_name = []
        else:
            self.cpe_searchable_name = cpe_searchable_name
    def factory(*args_, **kwargs_):
        if searchableCpeReferencesType.subclass:
            return searchableCpeReferencesType.subclass(*args_, **kwargs_)
        else:
            return searchableCpeReferencesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cpe_name(self): return self.cpe_name
    def set_cpe_name(self, cpe_name): self.cpe_name = cpe_name
    def add_cpe_name(self, value): self.cpe_name.append(value)
    def insert_cpe_name_at(self, index, value): self.cpe_name.insert(index, value)
    def replace_cpe_name_at(self, index, value): self.cpe_name[index] = value
    def get_cpe_searchable_name(self): return self.cpe_searchable_name
    def set_cpe_searchable_name(self, cpe_searchable_name): self.cpe_searchable_name = cpe_searchable_name
    def add_cpe_searchable_name(self, value): self.cpe_searchable_name.append(value)
    def insert_cpe_searchable_name_at(self, index, value): self.cpe_searchable_name.insert(index, value)
    def replace_cpe_searchable_name_at(self, index, value): self.cpe_searchable_name[index] = value
    def validate_cpeNamePatternType(self, value):
        # Validate type cpeNamePatternType, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_cpeNamePatternType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cpeNamePatternType_patterns_, ))
    validate_cpeNamePatternType_patterns_ = [['^[c][pP][eE]:/[AHOaho]?(:[A-Za-z0-9._\\-~%]*){0,6}$']]
    def validate_cpeSearchableNamePatternType(self, value):
        # Validate type cpeSearchableNamePatternType, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_cpeSearchableNamePatternType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cpeSearchableNamePatternType_patterns_, ))
    validate_cpeSearchableNamePatternType_patterns_ = [['^[c][pP][eE]:/[AHOaho]?(:[A-Za-z0-9._\\-~%*]*){0,6}$']]
    def hasContent_(self):
        if (
            self.cpe_name or
            self.cpe_searchable_name
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='searchableCpeReferencesType', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='searchableCpeReferencesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='searchableCpeReferencesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='searchableCpeReferencesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='searchableCpeReferencesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for cpe_name_ in self.cpe_name:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scpe-name>%s</%scpe-name>%s' % (namespace_, self.gds_format_string(quote_xml(cpe_name_).encode(ExternalEncoding), input_name='cpe-name'), namespace_, eol_))
        for cpe_searchable_name_ in self.cpe_searchable_name:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scpe-searchable-name>%s</%scpe-searchable-name>%s' % (namespace_, self.gds_format_string(quote_xml(cpe_searchable_name_).encode(ExternalEncoding), input_name='cpe-searchable-name'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='searchableCpeReferencesType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('cpe_name=[\n')
        level += 1
        for cpe_name_ in self.cpe_name:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(cpe_name_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('cpe_searchable_name=[\n')
        level += 1
        for cpe_searchable_name_ in self.cpe_searchable_name:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(cpe_searchable_name_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cpe-name':
            cpe_name_ = child_.text
            cpe_name_ = self.gds_validate_string(cpe_name_, node, 'cpe_name')
            self.cpe_name.append(cpe_name_)
            self.validate_cpeNamePatternType(self.cpe_name)    # validate type cpeNamePatternType
        elif nodeName_ == 'cpe-searchable-name':
            cpe_searchable_name_ = child_.text
            cpe_searchable_name_ = self.gds_validate_string(cpe_searchable_name_, node, 'cpe_searchable_name')
            self.cpe_searchable_name.append(cpe_searchable_name_)
            self.validate_cpeSearchableNamePatternType(self.cpe_searchable_name)    # validate type cpeSearchableNamePatternType
# end class searchableCpeReferencesType


class controlMappingsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, control_mapping=None):
        self.original_tagname_ = None
        if control_mapping is None:
            self.control_mapping = []
        else:
            self.control_mapping = control_mapping
    def factory(*args_, **kwargs_):
        if controlMappingsType.subclass:
            return controlMappingsType.subclass(*args_, **kwargs_)
        else:
            return controlMappingsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_control_mapping(self): return self.control_mapping
    def set_control_mapping(self, control_mapping): self.control_mapping = control_mapping
    def add_control_mapping(self, value): self.control_mapping.append(value)
    def insert_control_mapping_at(self, index, value): self.control_mapping.insert(index, value)
    def replace_control_mapping_at(self, index, value): self.control_mapping[index] = value
    def hasContent_(self):
        if (
            self.control_mapping
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='controlMappingsType', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='controlMappingsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='controlMappingsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='controlMappingsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='controlMappingsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for control_mapping_ in self.control_mapping:
            control_mapping_.export(outfile, level, namespace_, name_='control-mapping', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='controlMappingsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('control_mapping=[\n')
        level += 1
        for control_mapping_ in self.control_mapping:
            showIndent(outfile, level)
            outfile.write('model_.controlMappingType(\n')
            control_mapping_.exportLiteral(outfile, level, name_='controlMappingType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'control-mapping':
            obj_ = controlMappingType.factory()
            obj_.build(child_)
            self.control_mapping.append(obj_)
            obj_.original_tagname_ = 'control-mapping'
# end class controlMappingsType


class controlMappingType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, source=None, system_id=None, last_modified=None, mapping=None):
        self.original_tagname_ = None
        self.source = _cast(None, source)
        self.system_id = _cast(None, system_id)
        self.last_modified = _cast(None, last_modified)
        if mapping is None:
            self.mapping = []
        else:
            self.mapping = mapping
    def factory(*args_, **kwargs_):
        if controlMappingType.subclass:
            return controlMappingType.subclass(*args_, **kwargs_)
        else:
            return controlMappingType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_mapping(self): return self.mapping
    def set_mapping(self, mapping): self.mapping = mapping
    def add_mapping(self, value): self.mapping.append(value)
    def insert_mapping_at(self, index, value): self.mapping.insert(index, value)
    def replace_mapping_at(self, index, value): self.mapping[index] = value
    def get_source(self): return self.source
    def set_source(self, source): self.source = source
    def get_system_id(self): return self.system_id
    def set_system_id(self, system_id): self.system_id = system_id
    def get_last_modified(self): return self.last_modified
    def set_last_modified(self, last_modified): self.last_modified = last_modified
    def hasContent_(self):
        if (
            self.mapping
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='controlMappingType', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='controlMappingType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='controlMappingType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='controlMappingType'):
        if self.source is not None and 'source' not in already_processed:
            already_processed.add('source')
            outfile.write(' source=%s' % (quote_attrib(self.source), ))
        if self.system_id is not None and 'system_id' not in already_processed:
            already_processed.add('system_id')
            outfile.write(' system-id=%s' % (quote_attrib(self.system_id), ))
        if self.last_modified is not None and 'last_modified' not in already_processed:
            already_processed.add('last_modified')
            outfile.write(' last-modified=%s' % (quote_attrib(self.last_modified), ))
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='controlMappingType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for mapping_ in self.mapping:
            mapping_.export(outfile, level, namespace_, name_='mapping', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='controlMappingType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.source is not None and 'source' not in already_processed:
            already_processed.add('source')
            showIndent(outfile, level)
            outfile.write('source=%s,\n' % (self.source,))
        if self.system_id is not None and 'system_id' not in already_processed:
            already_processed.add('system_id')
            showIndent(outfile, level)
            outfile.write('system_id=%s,\n' % (self.system_id,))
        if self.last_modified is not None and 'last_modified' not in already_processed:
            already_processed.add('last_modified')
            showIndent(outfile, level)
            outfile.write('last_modified=%s,\n' % (self.last_modified,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('mapping=[\n')
        level += 1
        for mapping_ in self.mapping:
            showIndent(outfile, level)
            outfile.write('model_.mappingInstanceType(\n')
            mapping_.exportLiteral(outfile, level, name_='mappingInstanceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('source', node)
        if value is not None and 'source' not in already_processed:
            already_processed.add('source')
            self.source = value
        value = find_attr_value_('system-id', node)
        if value is not None and 'system-id' not in already_processed:
            already_processed.add('system-id')
            self.system_id = value
        value = find_attr_value_('last-modified', node)
        if value is not None and 'last-modified' not in already_processed:
            already_processed.add('last-modified')
            self.last_modified = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'mapping':
            obj_ = mappingInstanceType.factory()
            obj_.build(child_)
            self.mapping.append(obj_)
            obj_.original_tagname_ = 'mapping'
# end class controlMappingType


class mappingInstanceType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, published=None, valueOf_=None):
        self.original_tagname_ = None
        self.published = _cast(None, published)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if mappingInstanceType.subclass:
            return mappingInstanceType.subclass(*args_, **kwargs_)
        else:
            return mappingInstanceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_published(self): return self.published
    def set_published(self, published): self.published = published
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='mappingInstanceType', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='mappingInstanceType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='mappingInstanceType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='mappingInstanceType'):
        if self.published is not None and 'published' not in already_processed:
            already_processed.add('published')
            outfile.write(' published=%s' % (quote_attrib(self.published), ))
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='mappingInstanceType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='mappingInstanceType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.published is not None and 'published' not in already_processed:
            already_processed.add('published')
            showIndent(outfile, level)
            outfile.write('published=%s,\n' % (self.published,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('published', node)
        if value is not None and 'published' not in already_processed:
            already_processed.add('published')
            self.published = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class mappingInstanceType


class assessmentMethodType(GeneratedsSuper):
    """Denotes a scanner and required configuration that is capable of
    detecting the referenced vulnerability. May also be an OVAL
    definition and omit scanner name.Identifies a tool and any
    associated information about the tool, such as signature
    versions, that indicate the tool is capable or properly
    detecting and/or remdiating the vulnerability or
    misconfiguration"""
    subclass = None
    superclass = None
    def __init__(self, assessment_check=None, assessment_engine=None, extensiontype_=None):
        self.original_tagname_ = None
        self.assessment_check = assessment_check
        if assessment_engine is None:
            self.assessment_engine = []
        else:
            self.assessment_engine = assessment_engine
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if assessmentMethodType.subclass:
            return assessmentMethodType.subclass(*args_, **kwargs_)
        else:
            return assessmentMethodType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_assessment_check(self): return self.assessment_check
    def set_assessment_check(self, assessment_check): self.assessment_check = assessment_check
    def get_assessment_engine(self): return self.assessment_engine
    def set_assessment_engine(self, assessment_engine): self.assessment_engine = assessment_engine
    def add_assessment_engine(self, value): self.assessment_engine.append(value)
    def insert_assessment_engine_at(self, index, value): self.assessment_engine.insert(index, value)
    def replace_assessment_engine_at(self, index, value): self.assessment_engine[index] = value
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_cpeNamePatternType(self, value):
        # Validate type cpeNamePatternType, a restriction on xsd:anyURI.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_cpeNamePatternType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cpeNamePatternType_patterns_, ))
    validate_cpeNamePatternType_patterns_ = [['^[c][pP][eE]:/[AHOaho]?(:[A-Za-z0-9._\\-~%]*){0,6}$']]
    def hasContent_(self):
        if (
            self.assessment_check is not None or
            self.assessment_engine
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='assessmentMethodType', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='assessmentMethodType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='assessmentMethodType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='assessmentMethodType'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='assessmentMethodType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.assessment_check is not None:
            self.assessment_check.export(outfile, level, namespace_, name_='assessment-check', pretty_print=pretty_print)
        for assessment_engine_ in self.assessment_engine:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sassessment-engine>%s</%sassessment-engine>%s' % (namespace_, self.gds_format_string(quote_xml(assessment_engine_).encode(ExternalEncoding), input_name='assessment-engine'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='assessmentMethodType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.assessment_check is not None:
            showIndent(outfile, level)
            outfile.write('assessment_check=model_.checkReferenceType(\n')
            self.assessment_check.exportLiteral(outfile, level, name_='assessment_check')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('assessment_engine=[\n')
        level += 1
        for assessment_engine_ in self.assessment_engine:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(assessment_engine_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'assessment-check':
            obj_ = checkReferenceType.factory()
            obj_.build(child_)
            self.assessment_check = obj_
            obj_.original_tagname_ = 'assessment-check'
        elif nodeName_ == 'assessment-engine':
            assessment_engine_ = child_.text
            assessment_engine_ = self.gds_validate_string(assessment_engine_, node, 'assessment_engine')
            self.assessment_engine.append(assessment_engine_)
            self.validate_cpeNamePatternType(self.assessment_engine)    # validate type cpeNamePatternType
# end class assessmentMethodType


class identifyableAssessmentMethodType(assessmentMethodType):
    subclass = None
    superclass = assessmentMethodType
    def __init__(self, assessment_check=None, assessment_engine=None, id=None):
        self.original_tagname_ = None
        super(identifyableAssessmentMethodType, self).__init__(assessment_check, assessment_engine, )
        self.id = _cast(None, id)
    def factory(*args_, **kwargs_):
        if identifyableAssessmentMethodType.subclass:
            return identifyableAssessmentMethodType.subclass(*args_, **kwargs_)
        else:
            return identifyableAssessmentMethodType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            super(identifyableAssessmentMethodType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='identifyableAssessmentMethodType', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='identifyableAssessmentMethodType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='identifyableAssessmentMethodType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='identifyableAssessmentMethodType'):
        super(identifyableAssessmentMethodType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='identifyableAssessmentMethodType')
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='identifyableAssessmentMethodType', fromsubclass_=False, pretty_print=True):
        super(identifyableAssessmentMethodType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='identifyableAssessmentMethodType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id=%s,\n' % (self.id,))
        super(identifyableAssessmentMethodType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(identifyableAssessmentMethodType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        super(identifyableAssessmentMethodType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(identifyableAssessmentMethodType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class identifyableAssessmentMethodType


class accessComplexityType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, approximated='false', valueOf_=None):
        self.original_tagname_ = None
        self.approximated = _cast(None, approximated)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if accessComplexityType.subclass:
            return accessComplexityType.subclass(*args_, **kwargs_)
        else:
            return accessComplexityType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_approximated(self): return self.approximated
    def set_approximated(self, approximated): self.approximated = approximated
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='accessComplexityType', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='accessComplexityType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='accessComplexityType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='accessComplexityType'):
        if self.approximated is not None and 'approximated' not in already_processed:
            already_processed.add('approximated')
            outfile.write(' approximated=%s' % (quote_attrib(self.approximated), ))
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='accessComplexityType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='accessComplexityType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.approximated is not None and 'approximated' not in already_processed:
            already_processed.add('approximated')
            showIndent(outfile, level)
            outfile.write('approximated=%s,\n' % (self.approximated,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('approximated', node)
        if value is not None and 'approximated' not in already_processed:
            already_processed.add('approximated')
            self.approximated = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class accessComplexityType


class accessVectorType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, approximated='false', valueOf_=None):
        self.original_tagname_ = None
        self.approximated = _cast(None, approximated)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if accessVectorType.subclass:
            return accessVectorType.subclass(*args_, **kwargs_)
        else:
            return accessVectorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_approximated(self): return self.approximated
    def set_approximated(self, approximated): self.approximated = approximated
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='accessVectorType', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='accessVectorType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='accessVectorType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='accessVectorType'):
        if self.approximated is not None and 'approximated' not in already_processed:
            already_processed.add('approximated')
            outfile.write(' approximated=%s' % (quote_attrib(self.approximated), ))
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='accessVectorType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='accessVectorType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.approximated is not None and 'approximated' not in already_processed:
            already_processed.add('approximated')
            showIndent(outfile, level)
            outfile.write('approximated=%s,\n' % (self.approximated,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('approximated', node)
        if value is not None and 'approximated' not in already_processed:
            already_processed.add('approximated')
            self.approximated = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class accessVectorType


class ciaRequirementType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, approximated='false', valueOf_=None):
        self.original_tagname_ = None
        self.approximated = _cast(None, approximated)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if ciaRequirementType.subclass:
            return ciaRequirementType.subclass(*args_, **kwargs_)
        else:
            return ciaRequirementType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_approximated(self): return self.approximated
    def set_approximated(self, approximated): self.approximated = approximated
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='ciaRequirementType', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ciaRequirementType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='ciaRequirementType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='ciaRequirementType'):
        if self.approximated is not None and 'approximated' not in already_processed:
            already_processed.add('approximated')
            outfile.write(' approximated=%s' % (quote_attrib(self.approximated), ))
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='ciaRequirementType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='ciaRequirementType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.approximated is not None and 'approximated' not in already_processed:
            already_processed.add('approximated')
            showIndent(outfile, level)
            outfile.write('approximated=%s,\n' % (self.approximated,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('approximated', node)
        if value is not None and 'approximated' not in already_processed:
            already_processed.add('approximated')
            self.approximated = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ciaRequirementType


class collateralDamagePotentialType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, approximated='false', valueOf_=None):
        self.original_tagname_ = None
        self.approximated = _cast(None, approximated)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if collateralDamagePotentialType.subclass:
            return collateralDamagePotentialType.subclass(*args_, **kwargs_)
        else:
            return collateralDamagePotentialType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_approximated(self): return self.approximated
    def set_approximated(self, approximated): self.approximated = approximated
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='collateralDamagePotentialType', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='collateralDamagePotentialType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='collateralDamagePotentialType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='collateralDamagePotentialType'):
        if self.approximated is not None and 'approximated' not in already_processed:
            already_processed.add('approximated')
            outfile.write(' approximated=%s' % (quote_attrib(self.approximated), ))
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='collateralDamagePotentialType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='collateralDamagePotentialType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.approximated is not None and 'approximated' not in already_processed:
            already_processed.add('approximated')
            showIndent(outfile, level)
            outfile.write('approximated=%s,\n' % (self.approximated,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('approximated', node)
        if value is not None and 'approximated' not in already_processed:
            already_processed.add('approximated')
            self.approximated = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class collateralDamagePotentialType


class targetDistributionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, approximated='false', valueOf_=None):
        self.original_tagname_ = None
        self.approximated = _cast(None, approximated)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if targetDistributionType.subclass:
            return targetDistributionType.subclass(*args_, **kwargs_)
        else:
            return targetDistributionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_approximated(self): return self.approximated
    def set_approximated(self, approximated): self.approximated = approximated
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='targetDistributionType', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='targetDistributionType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='targetDistributionType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='targetDistributionType'):
        if self.approximated is not None and 'approximated' not in already_processed:
            already_processed.add('approximated')
            outfile.write(' approximated=%s' % (quote_attrib(self.approximated), ))
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='targetDistributionType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='targetDistributionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.approximated is not None and 'approximated' not in already_processed:
            already_processed.add('approximated')
            showIndent(outfile, level)
            outfile.write('approximated=%s,\n' % (self.approximated,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('approximated', node)
        if value is not None and 'approximated' not in already_processed:
            already_processed.add('approximated')
            self.approximated = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class targetDistributionType


class ciaType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, approximated='false', valueOf_=None):
        self.original_tagname_ = None
        self.approximated = _cast(None, approximated)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if ciaType.subclass:
            return ciaType.subclass(*args_, **kwargs_)
        else:
            return ciaType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_approximated(self): return self.approximated
    def set_approximated(self, approximated): self.approximated = approximated
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='ciaType', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ciaType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='ciaType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='ciaType'):
        if self.approximated is not None and 'approximated' not in already_processed:
            already_processed.add('approximated')
            outfile.write(' approximated=%s' % (quote_attrib(self.approximated), ))
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='ciaType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='ciaType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.approximated is not None and 'approximated' not in already_processed:
            already_processed.add('approximated')
            showIndent(outfile, level)
            outfile.write('approximated=%s,\n' % (self.approximated,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('approximated', node)
        if value is not None and 'approximated' not in already_processed:
            already_processed.add('approximated')
            self.approximated = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ciaType


class authenticationType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, approximated='false', valueOf_=None):
        self.original_tagname_ = None
        self.approximated = _cast(None, approximated)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if authenticationType.subclass:
            return authenticationType.subclass(*args_, **kwargs_)
        else:
            return authenticationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_approximated(self): return self.approximated
    def set_approximated(self, approximated): self.approximated = approximated
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='authenticationType', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='authenticationType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='authenticationType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='authenticationType'):
        if self.approximated is not None and 'approximated' not in already_processed:
            already_processed.add('approximated')
            outfile.write(' approximated=%s' % (quote_attrib(self.approximated), ))
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='authenticationType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='authenticationType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.approximated is not None and 'approximated' not in already_processed:
            already_processed.add('approximated')
            showIndent(outfile, level)
            outfile.write('approximated=%s,\n' % (self.approximated,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('approximated', node)
        if value is not None and 'approximated' not in already_processed:
            already_processed.add('approximated')
            self.approximated = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class authenticationType


class remediationLevelType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, approximated='false', valueOf_=None):
        self.original_tagname_ = None
        self.approximated = _cast(None, approximated)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if remediationLevelType.subclass:
            return remediationLevelType.subclass(*args_, **kwargs_)
        else:
            return remediationLevelType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_approximated(self): return self.approximated
    def set_approximated(self, approximated): self.approximated = approximated
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='remediationLevelType', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='remediationLevelType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='remediationLevelType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='remediationLevelType'):
        if self.approximated is not None and 'approximated' not in already_processed:
            already_processed.add('approximated')
            outfile.write(' approximated=%s' % (quote_attrib(self.approximated), ))
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='remediationLevelType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='remediationLevelType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.approximated is not None and 'approximated' not in already_processed:
            already_processed.add('approximated')
            showIndent(outfile, level)
            outfile.write('approximated=%s,\n' % (self.approximated,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('approximated', node)
        if value is not None and 'approximated' not in already_processed:
            already_processed.add('approximated')
            self.approximated = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class remediationLevelType


class confidenceType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, approximated='false', valueOf_=None):
        self.original_tagname_ = None
        self.approximated = _cast(None, approximated)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if confidenceType.subclass:
            return confidenceType.subclass(*args_, **kwargs_)
        else:
            return confidenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_approximated(self): return self.approximated
    def set_approximated(self, approximated): self.approximated = approximated
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='confidenceType', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='confidenceType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='confidenceType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='confidenceType'):
        if self.approximated is not None and 'approximated' not in already_processed:
            already_processed.add('approximated')
            outfile.write(' approximated=%s' % (quote_attrib(self.approximated), ))
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='confidenceType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='confidenceType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.approximated is not None and 'approximated' not in already_processed:
            already_processed.add('approximated')
            showIndent(outfile, level)
            outfile.write('approximated=%s,\n' % (self.approximated,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('approximated', node)
        if value is not None and 'approximated' not in already_processed:
            already_processed.add('approximated')
            self.approximated = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class confidenceType


class exploitabilityType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, approximated='false', valueOf_=None):
        self.original_tagname_ = None
        self.approximated = _cast(None, approximated)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if exploitabilityType.subclass:
            return exploitabilityType.subclass(*args_, **kwargs_)
        else:
            return exploitabilityType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_approximated(self): return self.approximated
    def set_approximated(self, approximated): self.approximated = approximated
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='exploitabilityType', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='exploitabilityType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='exploitabilityType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='exploitabilityType'):
        if self.approximated is not None and 'approximated' not in already_processed:
            already_processed.add('approximated')
            outfile.write(' approximated=%s' % (quote_attrib(self.approximated), ))
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='exploitabilityType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='exploitabilityType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.approximated is not None and 'approximated' not in already_processed:
            already_processed.add('approximated')
            showIndent(outfile, level)
            outfile.write('approximated=%s,\n' % (self.approximated,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('approximated', node)
        if value is not None and 'approximated' not in already_processed:
            already_processed.add('approximated')
            self.approximated = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class exploitabilityType


class cvssType(GeneratedsSuper):
    """ "This schema was intentionally designed to avoid mixing classes and
    attributes between CVSS version 1, CVSS version 2, and future
    versions. Scores in the CVSS system are interdependent. The
    temporal score is a multiplier of the base score. The
    environmental score, in turn, is a multiplier of the temporal
    score. The ability to transfer these scores independently is
    provided on the assumption that the user understands the
    business logic. For any given metric, it is preferred that the
    score, as a minimum is provided, however the score can be re-
    created from the metrics or the multiplier and any scores they
    are dependent on." """
    subclass = None
    superclass = None
    def __init__(self, base_metrics=None, environmental_metrics=None, temporal_metrics=None):
        self.original_tagname_ = None
        if base_metrics is None:
            self.base_metrics = []
        else:
            self.base_metrics = base_metrics
        if environmental_metrics is None:
            self.environmental_metrics = []
        else:
            self.environmental_metrics = environmental_metrics
        if temporal_metrics is None:
            self.temporal_metrics = []
        else:
            self.temporal_metrics = temporal_metrics
    def factory(*args_, **kwargs_):
        if cvssType.subclass:
            return cvssType.subclass(*args_, **kwargs_)
        else:
            return cvssType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_base_metrics(self): return self.base_metrics
    def set_base_metrics(self, base_metrics): self.base_metrics = base_metrics
    def add_base_metrics(self, value): self.base_metrics.append(value)
    def insert_base_metrics_at(self, index, value): self.base_metrics.insert(index, value)
    def replace_base_metrics_at(self, index, value): self.base_metrics[index] = value
    def get_environmental_metrics(self): return self.environmental_metrics
    def set_environmental_metrics(self, environmental_metrics): self.environmental_metrics = environmental_metrics
    def add_environmental_metrics(self, value): self.environmental_metrics.append(value)
    def insert_environmental_metrics_at(self, index, value): self.environmental_metrics.insert(index, value)
    def replace_environmental_metrics_at(self, index, value): self.environmental_metrics[index] = value
    def get_temporal_metrics(self): return self.temporal_metrics
    def set_temporal_metrics(self, temporal_metrics): self.temporal_metrics = temporal_metrics
    def add_temporal_metrics(self, value): self.temporal_metrics.append(value)
    def insert_temporal_metrics_at(self, index, value): self.temporal_metrics.insert(index, value)
    def replace_temporal_metrics_at(self, index, value): self.temporal_metrics[index] = value
    def hasContent_(self):
        if (
            self.base_metrics or
            self.environmental_metrics or
            self.temporal_metrics
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='cvssType', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cvssType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='cvssType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='cvssType'):
        pass
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='cvssType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for base_metrics_ in self.base_metrics:
            base_metrics_.export(outfile, level, namespace_, name_='base_metrics', pretty_print=pretty_print)
        for environmental_metrics_ in self.environmental_metrics:
            environmental_metrics_.export(outfile, level, namespace_, name_='environmental_metrics', pretty_print=pretty_print)
        for temporal_metrics_ in self.temporal_metrics:
            temporal_metrics_.export(outfile, level, namespace_, name_='temporal_metrics', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='cvssType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('base_metrics=[\n')
        level += 1
        for base_metrics_ in self.base_metrics:
            showIndent(outfile, level)
            outfile.write('model_.baseMetricsType(\n')
            base_metrics_.exportLiteral(outfile, level, name_='baseMetricsType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('environmental_metrics=[\n')
        level += 1
        for environmental_metrics_ in self.environmental_metrics:
            showIndent(outfile, level)
            outfile.write('model_.environmentalMetricsType(\n')
            environmental_metrics_.exportLiteral(outfile, level, name_='environmentalMetricsType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('temporal_metrics=[\n')
        level += 1
        for temporal_metrics_ in self.temporal_metrics:
            showIndent(outfile, level)
            outfile.write('model_.temporalMetricsType(\n')
            temporal_metrics_.exportLiteral(outfile, level, name_='temporalMetricsType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'base_metrics':
            obj_ = baseMetricsType.factory()
            obj_.build(child_)
            self.base_metrics.append(obj_)
            obj_.original_tagname_ = 'base_metrics'
        elif nodeName_ == 'environmental_metrics':
            obj_ = environmentalMetricsType.factory()
            obj_.build(child_)
            self.environmental_metrics.append(obj_)
            obj_.original_tagname_ = 'environmental_metrics'
        elif nodeName_ == 'temporal_metrics':
            obj_ = temporalMetricsType.factory()
            obj_.build(child_)
            self.temporal_metrics.append(obj_)
            obj_.original_tagname_ = 'temporal_metrics'
# end class cvssType


class cvssImpactType(cvssType):
    subclass = None
    superclass = cvssType
    def __init__(self, base_metrics=None, environmental_metrics=None, temporal_metrics=None):
        self.original_tagname_ = None
        super(cvssImpactType, self).__init__(base_metrics, environmental_metrics, temporal_metrics, )
        self.base_metrics = base_metrics
        self.environmental_metrics = environmental_metrics
        self.temporal_metrics = temporal_metrics
    def factory(*args_, **kwargs_):
        if cvssImpactType.subclass:
            return cvssImpactType.subclass(*args_, **kwargs_)
        else:
            return cvssImpactType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_base_metrics(self): return self.base_metrics
    def set_base_metrics(self, base_metrics): self.base_metrics = base_metrics
    def get_environmental_metrics(self): return self.environmental_metrics
    def set_environmental_metrics(self, environmental_metrics): self.environmental_metrics = environmental_metrics
    def get_temporal_metrics(self): return self.temporal_metrics
    def set_temporal_metrics(self, temporal_metrics): self.temporal_metrics = temporal_metrics
    def hasContent_(self):
        if (
            self.base_metrics is not None or
            self.environmental_metrics is not None or
            self.temporal_metrics is not None or
            super(cvssImpactType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='cvssImpactType', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cvssImpactType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='cvssImpactType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='cvssImpactType'):
        super(cvssImpactType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='cvssImpactType')
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='cvssImpactType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.base_metrics is not None:
            self.base_metrics.export(outfile, level, namespace_, name_='base_metrics', pretty_print=pretty_print)
        if self.environmental_metrics is not None:
            self.environmental_metrics.export(outfile, level, namespace_, name_='environmental_metrics', pretty_print=pretty_print)
        if self.temporal_metrics is not None:
            self.temporal_metrics.export(outfile, level, namespace_, name_='temporal_metrics', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='cvssImpactType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(cvssImpactType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(cvssImpactType, self).exportLiteralChildren(outfile, level, name_)
        if self.base_metrics is not None:
            showIndent(outfile, level)
            outfile.write('base_metrics=model_.baseMetricsType(\n')
            self.base_metrics.exportLiteral(outfile, level, name_='base_metrics')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.environmental_metrics is not None:
            showIndent(outfile, level)
            outfile.write('environmental_metrics=model_.environmentalMetricsType(\n')
            self.environmental_metrics.exportLiteral(outfile, level, name_='environmental_metrics')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.temporal_metrics is not None:
            showIndent(outfile, level)
            outfile.write('temporal_metrics=model_.temporalMetricsType(\n')
            self.temporal_metrics.exportLiteral(outfile, level, name_='temporal_metrics')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(cvssImpactType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'base_metrics':
            obj_ = baseMetricsType.factory()
            obj_.build(child_)
            self.base_metrics = obj_
            obj_.original_tagname_ = 'base_metrics'
        elif nodeName_ == 'environmental_metrics':
            obj_ = environmentalMetricsType.factory()
            obj_.build(child_)
            self.environmental_metrics = obj_
            obj_.original_tagname_ = 'environmental_metrics'
        elif nodeName_ == 'temporal_metrics':
            obj_ = temporalMetricsType.factory()
            obj_.build(child_)
            self.temporal_metrics = obj_
            obj_.original_tagname_ = 'temporal_metrics'
# end class cvssImpactType


class cvssImpactBaseType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, base_metrics=None, extensiontype_=None):
        self.original_tagname_ = None
        self.base_metrics = base_metrics
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if cvssImpactBaseType.subclass:
            return cvssImpactBaseType.subclass(*args_, **kwargs_)
        else:
            return cvssImpactBaseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_base_metrics(self): return self.base_metrics
    def set_base_metrics(self, base_metrics): self.base_metrics = base_metrics
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.base_metrics is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='cvssImpactBaseType', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cvssImpactBaseType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='cvssImpactBaseType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='cvssImpactBaseType'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='cvssImpactBaseType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.base_metrics is not None:
            self.base_metrics.export(outfile, level, namespace_, name_='base_metrics', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='cvssImpactBaseType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.base_metrics is not None:
            showIndent(outfile, level)
            outfile.write('base_metrics=model_.baseMetricsType(\n')
            self.base_metrics.exportLiteral(outfile, level, name_='base_metrics')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'base_metrics':
            obj_ = baseMetricsType.factory()
            obj_.build(child_)
            self.base_metrics = obj_
            obj_.original_tagname_ = 'base_metrics'
# end class cvssImpactBaseType


class cvssImpactTemporalType(cvssImpactBaseType):
    subclass = None
    superclass = cvssImpactBaseType
    def __init__(self, base_metrics=None, temporal_metrics=None, extensiontype_=None):
        self.original_tagname_ = None
        super(cvssImpactTemporalType, self).__init__(base_metrics, extensiontype_, )
        self.temporal_metrics = temporal_metrics
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if cvssImpactTemporalType.subclass:
            return cvssImpactTemporalType.subclass(*args_, **kwargs_)
        else:
            return cvssImpactTemporalType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_temporal_metrics(self): return self.temporal_metrics
    def set_temporal_metrics(self, temporal_metrics): self.temporal_metrics = temporal_metrics
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.temporal_metrics is not None or
            super(cvssImpactTemporalType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='cvssImpactTemporalType', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cvssImpactTemporalType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='cvssImpactTemporalType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='cvssImpactTemporalType'):
        super(cvssImpactTemporalType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='cvssImpactTemporalType')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='cvssImpactTemporalType', fromsubclass_=False, pretty_print=True):
        super(cvssImpactTemporalType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.temporal_metrics is not None:
            self.temporal_metrics.export(outfile, level, namespace_, name_='temporal_metrics', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='cvssImpactTemporalType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(cvssImpactTemporalType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(cvssImpactTemporalType, self).exportLiteralChildren(outfile, level, name_)
        if self.temporal_metrics is not None:
            showIndent(outfile, level)
            outfile.write('temporal_metrics=model_.temporalMetricsType(\n')
            self.temporal_metrics.exportLiteral(outfile, level, name_='temporal_metrics')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(cvssImpactTemporalType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'temporal_metrics':
            obj_ = temporalMetricsType.factory()
            obj_.build(child_)
            self.temporal_metrics = obj_
            obj_.original_tagname_ = 'temporal_metrics'
        super(cvssImpactTemporalType, self).buildChildren(child_, node, nodeName_, True)
# end class cvssImpactTemporalType


class cvssImpactEnvironmentalType(cvssImpactTemporalType):
    subclass = None
    superclass = cvssImpactTemporalType
    def __init__(self, base_metrics=None, temporal_metrics=None, environmental_metrics=None):
        self.original_tagname_ = None
        super(cvssImpactEnvironmentalType, self).__init__(base_metrics, temporal_metrics, )
        self.environmental_metrics = environmental_metrics
    def factory(*args_, **kwargs_):
        if cvssImpactEnvironmentalType.subclass:
            return cvssImpactEnvironmentalType.subclass(*args_, **kwargs_)
        else:
            return cvssImpactEnvironmentalType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_environmental_metrics(self): return self.environmental_metrics
    def set_environmental_metrics(self, environmental_metrics): self.environmental_metrics = environmental_metrics
    def hasContent_(self):
        if (
            self.environmental_metrics is not None or
            super(cvssImpactEnvironmentalType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='cvssImpactEnvironmentalType', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cvssImpactEnvironmentalType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='cvssImpactEnvironmentalType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='cvssImpactEnvironmentalType'):
        super(cvssImpactEnvironmentalType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='cvssImpactEnvironmentalType')
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='cvssImpactEnvironmentalType', fromsubclass_=False, pretty_print=True):
        super(cvssImpactEnvironmentalType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.environmental_metrics is not None:
            self.environmental_metrics.export(outfile, level, namespace_, name_='environmental_metrics', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='cvssImpactEnvironmentalType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(cvssImpactEnvironmentalType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(cvssImpactEnvironmentalType, self).exportLiteralChildren(outfile, level, name_)
        if self.environmental_metrics is not None:
            showIndent(outfile, level)
            outfile.write('environmental_metrics=model_.environmentalMetricsType(\n')
            self.environmental_metrics.exportLiteral(outfile, level, name_='environmental_metrics')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(cvssImpactEnvironmentalType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'environmental_metrics':
            obj_ = environmentalMetricsType.factory()
            obj_.build(child_)
            self.environmental_metrics = obj_
            obj_.original_tagname_ = 'environmental_metrics'
        super(cvssImpactEnvironmentalType, self).buildChildren(child_, node, nodeName_, True)
# end class cvssImpactEnvironmentalType


class metricsType(GeneratedsSuper):
    """Base type for metrics that defines common attributes of all
    metrics.Indicates if the metrics have been upgraded from a
    previous version of CVSS. If fields that were approximated will
    have an approximated attribute set to 'true'."""
    subclass = None
    superclass = None
    def __init__(self, upgraded_from_version=None, extensiontype_=None):
        self.original_tagname_ = None
        self.upgraded_from_version = _cast(None, upgraded_from_version)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if metricsType.subclass:
            return metricsType.subclass(*args_, **kwargs_)
        else:
            return metricsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_upgraded_from_version(self): return self.upgraded_from_version
    def set_upgraded_from_version(self, upgraded_from_version): self.upgraded_from_version = upgraded_from_version
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='metricsType', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='metricsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='metricsType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='metricsType'):
        if self.upgraded_from_version is not None and 'upgraded_from_version' not in already_processed:
            already_processed.add('upgraded_from_version')
            outfile.write(' upgraded-from-version=%s' % (quote_attrib(self.upgraded_from_version), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='metricsType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='metricsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.upgraded_from_version is not None and 'upgraded_from_version' not in already_processed:
            already_processed.add('upgraded_from_version')
            showIndent(outfile, level)
            outfile.write('upgraded_from_version=%s,\n' % (self.upgraded_from_version,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('upgraded-from-version', node)
        if value is not None and 'upgraded-from-version' not in already_processed:
            already_processed.add('upgraded-from-version')
            self.upgraded_from_version = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class metricsType


class baseMetricsType(metricsType):
    subclass = None
    superclass = metricsType
    def __init__(self, upgraded_from_version=None, score=None, exploit_subscore=None, impact_subscore=None, access_vector=None, access_complexity=None, authentication=None, confidentiality_impact=None, integrity_impact=None, availability_impact=None, source=None, generated_on_datetime=None):
        self.original_tagname_ = None
        super(baseMetricsType, self).__init__(upgraded_from_version, )
        self.score = score
        self.validate_zeroToTenDecimalType(self.score)
        self.exploit_subscore = exploit_subscore
        self.validate_zeroToTenDecimalType(self.exploit_subscore)
        self.impact_subscore = impact_subscore
        self.validate_zeroToTenDecimalType(self.impact_subscore)
        self.access_vector = access_vector
        self.access_complexity = access_complexity
        self.authentication = authentication
        self.confidentiality_impact = confidentiality_impact
        self.integrity_impact = integrity_impact
        self.availability_impact = availability_impact
        self.source = source
        self.generated_on_datetime = generated_on_datetime
    def factory(*args_, **kwargs_):
        if baseMetricsType.subclass:
            return baseMetricsType.subclass(*args_, **kwargs_)
        else:
            return baseMetricsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_score(self): return self.score
    def set_score(self, score): self.score = score
    def get_exploit_subscore(self): return self.exploit_subscore
    def set_exploit_subscore(self, exploit_subscore): self.exploit_subscore = exploit_subscore
    def get_impact_subscore(self): return self.impact_subscore
    def set_impact_subscore(self, impact_subscore): self.impact_subscore = impact_subscore
    def get_access_vector(self): return self.access_vector
    def set_access_vector(self, access_vector): self.access_vector = access_vector
    def get_access_complexity(self): return self.access_complexity
    def set_access_complexity(self, access_complexity): self.access_complexity = access_complexity
    def get_authentication(self): return self.authentication
    def set_authentication(self, authentication): self.authentication = authentication
    def get_confidentiality_impact(self): return self.confidentiality_impact
    def set_confidentiality_impact(self, confidentiality_impact): self.confidentiality_impact = confidentiality_impact
    def get_integrity_impact(self): return self.integrity_impact
    def set_integrity_impact(self, integrity_impact): self.integrity_impact = integrity_impact
    def get_availability_impact(self): return self.availability_impact
    def set_availability_impact(self, availability_impact): self.availability_impact = availability_impact
    def get_source(self): return self.source
    def set_source(self, source): self.source = source
    def get_generated_on_datetime(self): return self.generated_on_datetime
    def set_generated_on_datetime(self, generated_on_datetime): self.generated_on_datetime = generated_on_datetime
    def validate_zeroToTenDecimalType(self, value):
        # Validate type zeroToTenDecimalType, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on zeroToTenDecimalType' % {"value" : value} )
            if value > 10:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on zeroToTenDecimalType' % {"value" : value} )
    def hasContent_(self):
        if (
            self.score is not None or
            self.exploit_subscore is not None or
            self.impact_subscore is not None or
            self.access_vector is not None or
            self.access_complexity is not None or
            self.authentication is not None or
            self.confidentiality_impact is not None or
            self.integrity_impact is not None or
            self.availability_impact is not None or
            self.source is not None or
            self.generated_on_datetime is not None or
            super(baseMetricsType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='baseMetricsType', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='baseMetricsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='baseMetricsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='baseMetricsType'):
        super(baseMetricsType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='baseMetricsType')
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='baseMetricsType', fromsubclass_=False, pretty_print=True):
        super(baseMetricsType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.score is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sscore>%s</%sscore>%s' % (namespace_, self.gds_format_float(self.score, input_name='score'), namespace_, eol_))
        if self.exploit_subscore is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sexploit-subscore>%s</%sexploit-subscore>%s' % (namespace_, self.gds_format_float(self.exploit_subscore, input_name='exploit-subscore'), namespace_, eol_))
        if self.impact_subscore is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%simpact-subscore>%s</%simpact-subscore>%s' % (namespace_, self.gds_format_float(self.impact_subscore, input_name='impact-subscore'), namespace_, eol_))
        if self.access_vector is not None:
            self.access_vector.export(outfile, level, namespace_, name_='access-vector', pretty_print=pretty_print)
        if self.access_complexity is not None:
            self.access_complexity.export(outfile, level, namespace_, name_='access-complexity', pretty_print=pretty_print)
        if self.authentication is not None:
            self.authentication.export(outfile, level, namespace_, name_='authentication', pretty_print=pretty_print)
        if self.confidentiality_impact is not None:
            self.confidentiality_impact.export(outfile, level, namespace_, name_='confidentiality-impact', pretty_print=pretty_print)
        if self.integrity_impact is not None:
            self.integrity_impact.export(outfile, level, namespace_, name_='integrity-impact', pretty_print=pretty_print)
        if self.availability_impact is not None:
            self.availability_impact.export(outfile, level, namespace_, name_='availability-impact', pretty_print=pretty_print)
        if self.source is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssource>%s</%ssource>%s' % (namespace_, self.gds_format_string(quote_xml(self.source).encode(ExternalEncoding), input_name='source'), namespace_, eol_))
        if self.generated_on_datetime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sgenerated-on-datetime>%s</%sgenerated-on-datetime>%s' % (namespace_, self.gds_format_string(quote_xml(self.generated_on_datetime).encode(ExternalEncoding), input_name='generated-on-datetime'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='baseMetricsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(baseMetricsType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(baseMetricsType, self).exportLiteralChildren(outfile, level, name_)
        if self.score is not None:
            showIndent(outfile, level)
            outfile.write('score=%f,\n' % self.score)
        if self.exploit_subscore is not None:
            showIndent(outfile, level)
            outfile.write('exploit_subscore=%f,\n' % self.exploit_subscore)
        if self.impact_subscore is not None:
            showIndent(outfile, level)
            outfile.write('impact_subscore=%f,\n' % self.impact_subscore)
        if self.access_vector is not None:
            showIndent(outfile, level)
            outfile.write('access_vector=model_.accessVectorType(\n')
            self.access_vector.exportLiteral(outfile, level, name_='access_vector')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.access_complexity is not None:
            showIndent(outfile, level)
            outfile.write('access_complexity=model_.accessComplexityType(\n')
            self.access_complexity.exportLiteral(outfile, level, name_='access_complexity')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.authentication is not None:
            showIndent(outfile, level)
            outfile.write('authentication=model_.authenticationType(\n')
            self.authentication.exportLiteral(outfile, level, name_='authentication')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.confidentiality_impact is not None:
            showIndent(outfile, level)
            outfile.write('confidentiality_impact=model_.ciaType(\n')
            self.confidentiality_impact.exportLiteral(outfile, level, name_='confidentiality_impact')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.integrity_impact is not None:
            showIndent(outfile, level)
            outfile.write('integrity_impact=model_.ciaType(\n')
            self.integrity_impact.exportLiteral(outfile, level, name_='integrity_impact')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.availability_impact is not None:
            showIndent(outfile, level)
            outfile.write('availability_impact=model_.ciaType(\n')
            self.availability_impact.exportLiteral(outfile, level, name_='availability_impact')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.source is not None:
            showIndent(outfile, level)
            outfile.write('source=%s,\n' % quote_python(self.source).encode(ExternalEncoding))
        if self.generated_on_datetime is not None:
            showIndent(outfile, level)
            outfile.write('generated_on_datetime=%s,\n' % quote_python(self.generated_on_datetime).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(baseMetricsType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'score':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'score')
            self.score = fval_
            self.validate_zeroToTenDecimalType(self.score)    # validate type zeroToTenDecimalType
        elif nodeName_ == 'exploit-subscore':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'exploit_subscore')
            self.exploit_subscore = fval_
            self.validate_zeroToTenDecimalType(self.exploit_subscore)    # validate type zeroToTenDecimalType
        elif nodeName_ == 'impact-subscore':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'impact_subscore')
            self.impact_subscore = fval_
            self.validate_zeroToTenDecimalType(self.impact_subscore)    # validate type zeroToTenDecimalType
        elif nodeName_ == 'access-vector':
            obj_ = accessVectorType.factory()
            obj_.build(child_)
            self.access_vector = obj_
            obj_.original_tagname_ = 'access-vector'
        elif nodeName_ == 'access-complexity':
            obj_ = accessComplexityType.factory()
            obj_.build(child_)
            self.access_complexity = obj_
            obj_.original_tagname_ = 'access-complexity'
        elif nodeName_ == 'authentication':
            obj_ = authenticationType.factory()
            obj_.build(child_)
            self.authentication = obj_
            obj_.original_tagname_ = 'authentication'
        elif nodeName_ == 'confidentiality-impact':
            obj_ = ciaType.factory()
            obj_.build(child_)
            self.confidentiality_impact = obj_
            obj_.original_tagname_ = 'confidentiality-impact'
        elif nodeName_ == 'integrity-impact':
            obj_ = ciaType.factory()
            obj_.build(child_)
            self.integrity_impact = obj_
            obj_.original_tagname_ = 'integrity-impact'
        elif nodeName_ == 'availability-impact':
            obj_ = ciaType.factory()
            obj_.build(child_)
            self.availability_impact = obj_
            obj_.original_tagname_ = 'availability-impact'
        elif nodeName_ == 'source':
            source_ = child_.text
            source_ = self.gds_validate_string(source_, node, 'source')
            self.source = source_
        elif nodeName_ == 'generated-on-datetime':
            generated_on_datetime_ = child_.text
            generated_on_datetime_ = self.gds_validate_string(generated_on_datetime_, node, 'generated_on_datetime')
            self.generated_on_datetime = generated_on_datetime_
        super(baseMetricsType, self).buildChildren(child_, node, nodeName_, True)
# end class baseMetricsType


class environmentalMetricsType(metricsType):
    subclass = None
    superclass = metricsType
    def __init__(self, upgraded_from_version=None, score=None, collateral_damage_potential=None, target_distribution=None, confidentiality_requirement=None, integrity_requirement=None, availability_requirement=None, source=None, generated_on_datetime=None):
        self.original_tagname_ = None
        super(environmentalMetricsType, self).__init__(upgraded_from_version, )
        self.score = score
        self.validate_zeroToTenDecimalType(self.score)
        self.collateral_damage_potential = collateral_damage_potential
        self.target_distribution = target_distribution
        self.confidentiality_requirement = confidentiality_requirement
        self.integrity_requirement = integrity_requirement
        self.availability_requirement = availability_requirement
        self.source = source
        self.generated_on_datetime = generated_on_datetime
    def factory(*args_, **kwargs_):
        if environmentalMetricsType.subclass:
            return environmentalMetricsType.subclass(*args_, **kwargs_)
        else:
            return environmentalMetricsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_score(self): return self.score
    def set_score(self, score): self.score = score
    def get_collateral_damage_potential(self): return self.collateral_damage_potential
    def set_collateral_damage_potential(self, collateral_damage_potential): self.collateral_damage_potential = collateral_damage_potential
    def get_target_distribution(self): return self.target_distribution
    def set_target_distribution(self, target_distribution): self.target_distribution = target_distribution
    def get_confidentiality_requirement(self): return self.confidentiality_requirement
    def set_confidentiality_requirement(self, confidentiality_requirement): self.confidentiality_requirement = confidentiality_requirement
    def get_integrity_requirement(self): return self.integrity_requirement
    def set_integrity_requirement(self, integrity_requirement): self.integrity_requirement = integrity_requirement
    def get_availability_requirement(self): return self.availability_requirement
    def set_availability_requirement(self, availability_requirement): self.availability_requirement = availability_requirement
    def get_source(self): return self.source
    def set_source(self, source): self.source = source
    def get_generated_on_datetime(self): return self.generated_on_datetime
    def set_generated_on_datetime(self, generated_on_datetime): self.generated_on_datetime = generated_on_datetime
    def validate_zeroToTenDecimalType(self, value):
        # Validate type zeroToTenDecimalType, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on zeroToTenDecimalType' % {"value" : value} )
            if value > 10:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on zeroToTenDecimalType' % {"value" : value} )
    def hasContent_(self):
        if (
            self.score is not None or
            self.collateral_damage_potential is not None or
            self.target_distribution is not None or
            self.confidentiality_requirement is not None or
            self.integrity_requirement is not None or
            self.availability_requirement is not None or
            self.source is not None or
            self.generated_on_datetime is not None or
            super(environmentalMetricsType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='environmentalMetricsType', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='environmentalMetricsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='environmentalMetricsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='environmentalMetricsType'):
        super(environmentalMetricsType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='environmentalMetricsType')
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='environmentalMetricsType', fromsubclass_=False, pretty_print=True):
        super(environmentalMetricsType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.score is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sscore>%s</%sscore>%s' % (namespace_, self.gds_format_float(self.score, input_name='score'), namespace_, eol_))
        if self.collateral_damage_potential is not None:
            self.collateral_damage_potential.export(outfile, level, namespace_, name_='collateral-damage-potential', pretty_print=pretty_print)
        if self.target_distribution is not None:
            self.target_distribution.export(outfile, level, namespace_, name_='target-distribution', pretty_print=pretty_print)
        if self.confidentiality_requirement is not None:
            self.confidentiality_requirement.export(outfile, level, namespace_, name_='confidentiality-requirement', pretty_print=pretty_print)
        if self.integrity_requirement is not None:
            self.integrity_requirement.export(outfile, level, namespace_, name_='integrity-requirement', pretty_print=pretty_print)
        if self.availability_requirement is not None:
            self.availability_requirement.export(outfile, level, namespace_, name_='availability-requirement', pretty_print=pretty_print)
        if self.source is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssource>%s</%ssource>%s' % (namespace_, self.gds_format_string(quote_xml(self.source).encode(ExternalEncoding), input_name='source'), namespace_, eol_))
        if self.generated_on_datetime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sgenerated-on-datetime>%s</%sgenerated-on-datetime>%s' % (namespace_, self.gds_format_string(quote_xml(self.generated_on_datetime).encode(ExternalEncoding), input_name='generated-on-datetime'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='environmentalMetricsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(environmentalMetricsType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(environmentalMetricsType, self).exportLiteralChildren(outfile, level, name_)
        if self.score is not None:
            showIndent(outfile, level)
            outfile.write('score=%f,\n' % self.score)
        if self.collateral_damage_potential is not None:
            showIndent(outfile, level)
            outfile.write('collateral_damage_potential=model_.collateralDamagePotentialType(\n')
            self.collateral_damage_potential.exportLiteral(outfile, level, name_='collateral_damage_potential')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.target_distribution is not None:
            showIndent(outfile, level)
            outfile.write('target_distribution=model_.targetDistributionType(\n')
            self.target_distribution.exportLiteral(outfile, level, name_='target_distribution')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.confidentiality_requirement is not None:
            showIndent(outfile, level)
            outfile.write('confidentiality_requirement=model_.ciaRequirementType(\n')
            self.confidentiality_requirement.exportLiteral(outfile, level, name_='confidentiality_requirement')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.integrity_requirement is not None:
            showIndent(outfile, level)
            outfile.write('integrity_requirement=model_.ciaRequirementType(\n')
            self.integrity_requirement.exportLiteral(outfile, level, name_='integrity_requirement')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.availability_requirement is not None:
            showIndent(outfile, level)
            outfile.write('availability_requirement=model_.ciaRequirementType(\n')
            self.availability_requirement.exportLiteral(outfile, level, name_='availability_requirement')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.source is not None:
            showIndent(outfile, level)
            outfile.write('source=%s,\n' % quote_python(self.source).encode(ExternalEncoding))
        if self.generated_on_datetime is not None:
            showIndent(outfile, level)
            outfile.write('generated_on_datetime=%s,\n' % quote_python(self.generated_on_datetime).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(environmentalMetricsType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'score':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'score')
            self.score = fval_
            self.validate_zeroToTenDecimalType(self.score)    # validate type zeroToTenDecimalType
        elif nodeName_ == 'collateral-damage-potential':
            obj_ = collateralDamagePotentialType.factory()
            obj_.build(child_)
            self.collateral_damage_potential = obj_
            obj_.original_tagname_ = 'collateral-damage-potential'
        elif nodeName_ == 'target-distribution':
            obj_ = targetDistributionType.factory()
            obj_.build(child_)
            self.target_distribution = obj_
            obj_.original_tagname_ = 'target-distribution'
        elif nodeName_ == 'confidentiality-requirement':
            obj_ = ciaRequirementType.factory()
            obj_.build(child_)
            self.confidentiality_requirement = obj_
            obj_.original_tagname_ = 'confidentiality-requirement'
        elif nodeName_ == 'integrity-requirement':
            obj_ = ciaRequirementType.factory()
            obj_.build(child_)
            self.integrity_requirement = obj_
            obj_.original_tagname_ = 'integrity-requirement'
        elif nodeName_ == 'availability-requirement':
            obj_ = ciaRequirementType.factory()
            obj_.build(child_)
            self.availability_requirement = obj_
            obj_.original_tagname_ = 'availability-requirement'
        elif nodeName_ == 'source':
            source_ = child_.text
            source_ = self.gds_validate_string(source_, node, 'source')
            self.source = source_
        elif nodeName_ == 'generated-on-datetime':
            generated_on_datetime_ = child_.text
            generated_on_datetime_ = self.gds_validate_string(generated_on_datetime_, node, 'generated_on_datetime')
            self.generated_on_datetime = generated_on_datetime_
        super(environmentalMetricsType, self).buildChildren(child_, node, nodeName_, True)
# end class environmentalMetricsType


class temporalMetricsType(metricsType):
    subclass = None
    superclass = metricsType
    def __init__(self, upgraded_from_version=None, score=None, temporal_multiplier=None, exploitability=None, remediation_level=None, report_confidence=None, source=None, generated_on_datetime=None):
        self.original_tagname_ = None
        super(temporalMetricsType, self).__init__(upgraded_from_version, )
        self.score = score
        self.validate_zeroToTenDecimalType(self.score)
        self.temporal_multiplier = temporal_multiplier
        self.exploitability = exploitability
        self.remediation_level = remediation_level
        self.report_confidence = report_confidence
        self.source = source
        self.generated_on_datetime = generated_on_datetime
    def factory(*args_, **kwargs_):
        if temporalMetricsType.subclass:
            return temporalMetricsType.subclass(*args_, **kwargs_)
        else:
            return temporalMetricsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_score(self): return self.score
    def set_score(self, score): self.score = score
    def get_temporal_multiplier(self): return self.temporal_multiplier
    def set_temporal_multiplier(self, temporal_multiplier): self.temporal_multiplier = temporal_multiplier
    def get_exploitability(self): return self.exploitability
    def set_exploitability(self, exploitability): self.exploitability = exploitability
    def get_remediation_level(self): return self.remediation_level
    def set_remediation_level(self, remediation_level): self.remediation_level = remediation_level
    def get_report_confidence(self): return self.report_confidence
    def set_report_confidence(self, report_confidence): self.report_confidence = report_confidence
    def get_source(self): return self.source
    def set_source(self, source): self.source = source
    def get_generated_on_datetime(self): return self.generated_on_datetime
    def set_generated_on_datetime(self, generated_on_datetime): self.generated_on_datetime = generated_on_datetime
    def validate_zeroToTenDecimalType(self, value):
        # Validate type zeroToTenDecimalType, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on zeroToTenDecimalType' % {"value" : value} )
            if value > 10:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on zeroToTenDecimalType' % {"value" : value} )
    def hasContent_(self):
        if (
            self.score is not None or
            self.temporal_multiplier is not None or
            self.exploitability is not None or
            self.remediation_level is not None or
            self.report_confidence is not None or
            self.source is not None or
            self.generated_on_datetime is not None or
            super(temporalMetricsType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='temporalMetricsType', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='temporalMetricsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='temporalMetricsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='temporalMetricsType'):
        super(temporalMetricsType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='temporalMetricsType')
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='temporalMetricsType', fromsubclass_=False, pretty_print=True):
        super(temporalMetricsType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.score is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sscore>%s</%sscore>%s' % (namespace_, self.gds_format_float(self.score, input_name='score'), namespace_, eol_))
        if self.temporal_multiplier is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stemporal-multiplier>%s</%stemporal-multiplier>%s' % (namespace_, self.gds_format_string(quote_xml(self.temporal_multiplier).encode(ExternalEncoding), input_name='temporal-multiplier'), namespace_, eol_))
        if self.exploitability is not None:
            self.exploitability.export(outfile, level, namespace_, name_='exploitability', pretty_print=pretty_print)
        if self.remediation_level is not None:
            self.remediation_level.export(outfile, level, namespace_, name_='remediation-level', pretty_print=pretty_print)
        if self.report_confidence is not None:
            self.report_confidence.export(outfile, level, namespace_, name_='report-confidence', pretty_print=pretty_print)
        if self.source is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssource>%s</%ssource>%s' % (namespace_, self.gds_format_string(quote_xml(self.source).encode(ExternalEncoding), input_name='source'), namespace_, eol_))
        if self.generated_on_datetime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sgenerated-on-datetime>%s</%sgenerated-on-datetime>%s' % (namespace_, self.gds_format_string(quote_xml(self.generated_on_datetime).encode(ExternalEncoding), input_name='generated-on-datetime'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='temporalMetricsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(temporalMetricsType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(temporalMetricsType, self).exportLiteralChildren(outfile, level, name_)
        if self.score is not None:
            showIndent(outfile, level)
            outfile.write('score=%f,\n' % self.score)
        if self.temporal_multiplier is not None:
            showIndent(outfile, level)
            outfile.write('temporal_multiplier=%s,\n' % quote_python(self.temporal_multiplier).encode(ExternalEncoding))
        if self.exploitability is not None:
            showIndent(outfile, level)
            outfile.write('exploitability=model_.exploitabilityType(\n')
            self.exploitability.exportLiteral(outfile, level, name_='exploitability')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.remediation_level is not None:
            showIndent(outfile, level)
            outfile.write('remediation_level=model_.remediationLevelType(\n')
            self.remediation_level.exportLiteral(outfile, level, name_='remediation_level')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.report_confidence is not None:
            showIndent(outfile, level)
            outfile.write('report_confidence=model_.confidenceType(\n')
            self.report_confidence.exportLiteral(outfile, level, name_='report_confidence')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.source is not None:
            showIndent(outfile, level)
            outfile.write('source=%s,\n' % quote_python(self.source).encode(ExternalEncoding))
        if self.generated_on_datetime is not None:
            showIndent(outfile, level)
            outfile.write('generated_on_datetime=%s,\n' % quote_python(self.generated_on_datetime).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(temporalMetricsType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'score':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'score')
            self.score = fval_
            self.validate_zeroToTenDecimalType(self.score)    # validate type zeroToTenDecimalType
        elif nodeName_ == 'temporal-multiplier':
            temporal_multiplier_ = child_.text
            temporal_multiplier_ = self.gds_validate_string(temporal_multiplier_, node, 'temporal_multiplier')
            self.temporal_multiplier = temporal_multiplier_
        elif nodeName_ == 'exploitability':
            obj_ = exploitabilityType.factory()
            obj_.build(child_)
            self.exploitability = obj_
            obj_.original_tagname_ = 'exploitability'
        elif nodeName_ == 'remediation-level':
            obj_ = remediationLevelType.factory()
            obj_.build(child_)
            self.remediation_level = obj_
            obj_.original_tagname_ = 'remediation-level'
        elif nodeName_ == 'report-confidence':
            obj_ = confidenceType.factory()
            obj_.build(child_)
            self.report_confidence = obj_
            obj_.original_tagname_ = 'report-confidence'
        elif nodeName_ == 'source':
            source_ = child_.text
            source_ = self.gds_validate_string(source_, node, 'source')
            self.source = source_
        elif nodeName_ == 'generated-on-datetime':
            generated_on_datetime_ = child_.text
            generated_on_datetime_ = self.gds_validate_string(generated_on_datetime_, node, 'generated_on_datetime')
            self.generated_on_datetime = generated_on_datetime_
        super(temporalMetricsType, self).buildChildren(child_, node, nodeName_, True)
# end class temporalMetricsType


class localizedString(GeneratedsSuper):
    """String type with an optional language attribute. The default
    language is English.Locale code used for the string value. The
    default is "en"."""
    subclass = None
    superclass = None
    def __init__(self, lang='en', valueOf_=None, extensiontype_=None):
        self.original_tagname_ = None
        self.lang = _cast(None, lang)
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if localizedString.subclass:
            return localizedString.subclass(*args_, **kwargs_)
        else:
            return localizedString(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_lang(self): return self.lang
    def set_lang(self, lang): self.lang = lang
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='localizedString', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='localizedString')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='localizedString', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='localizedString'):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' lang=%s' % (self.gds_format_string(quote_attrib(self.lang).encode(ExternalEncoding), input_name='lang'), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='localizedString', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='localizedString'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            showIndent(outfile, level)
            outfile.write('lang="%s",\n' % (self.lang,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class localizedString


class localizedNormalizedString(GeneratedsSuper):
    """Normalized string type with an optional language attribute. The
    default language is English. This string cannot be empty.Locale
    code used for the string value. The default is "en"."""
    subclass = None
    superclass = None
    def __init__(self, lang='en', valueOf_=None, extensiontype_=None):
        self.original_tagname_ = None
        self.lang = _cast(None, lang)
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if localizedNormalizedString.subclass:
            return localizedNormalizedString.subclass(*args_, **kwargs_)
        else:
            return localizedNormalizedString(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_lang(self): return self.lang
    def set_lang(self, lang): self.lang = lang
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='localizedNormalizedString', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='localizedNormalizedString')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='localizedNormalizedString', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='localizedNormalizedString'):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' lang=%s' % (self.gds_format_string(quote_attrib(self.lang).encode(ExternalEncoding), input_name='lang'), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='localizedNormalizedString', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='localizedNormalizedString'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            showIndent(outfile, level)
            outfile.write('lang="%s",\n' % (self.lang,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class localizedNormalizedString


class BranchType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Type=None, Name=None, FullProductName=None, Branch=None):
        self.original_tagname_ = None
        self.Type = _cast(None, Type)
        self.Name = _cast(None, Name)
        self.FullProductName = FullProductName
        if Branch is None:
            self.Branch = []
        else:
            self.Branch = Branch
    def factory(*args_, **kwargs_):
        if BranchType.subclass:
            return BranchType.subclass(*args_, **kwargs_)
        else:
            return BranchType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_FullProductName(self): return self.FullProductName
    def set_FullProductName(self, FullProductName): self.FullProductName = FullProductName
    def get_Branch(self): return self.Branch
    def set_Branch(self, Branch): self.Branch = Branch
    def add_Branch(self, value): self.Branch.append(value)
    def insert_Branch_at(self, index, value): self.Branch.insert(index, value)
    def replace_Branch_at(self, index, value): self.Branch[index] = value
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def hasContent_(self):
        if (
            self.FullProductName is not None or
            self.Branch
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='BranchType', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1" xmlns:prod="http://www.icasi.org/CVRF/schema/prod/1.1" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BranchType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='BranchType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='BranchType'):
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            outfile.write(' Type=%s' % (quote_attrib(self.Type), ))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.add('Name')
            outfile.write(' Name=%s' % (self.gds_format_string(quote_attrib(self.Name).encode(ExternalEncoding), input_name='Name'), ))
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='BranchType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.FullProductName is not None:
            self.FullProductName.export(outfile, level, namespace_='prod:', name_='FullProductName', pretty_print=pretty_print)
        for Branch_ in self.Branch:
            Branch_.export(outfile, level, namespace_, name_='Branch', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='BranchType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            showIndent(outfile, level)
            outfile.write('Type=%s,\n' % (self.Type,))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.add('Name')
            showIndent(outfile, level)
            outfile.write('Name="%s",\n' % (self.Name,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.FullProductName is not None:
            showIndent(outfile, level)
            outfile.write('FullProductName=model_.FullProductName(\n')
            self.FullProductName.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Branch=[\n')
        level += 1
        for Branch_ in self.Branch:
            showIndent(outfile, level)
            outfile.write('model_.BranchType(\n')
            Branch_.exportLiteral(outfile, level, name_='BranchType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            self.Type = value
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.add('Name')
            self.Name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FullProductName':
            obj_ = FullProductName.factory()
            obj_.build(child_)
            self.FullProductName = obj_
            obj_.original_tagname_ = 'FullProductName'
        elif nodeName_ == 'Branch':
            obj_ = BranchType.factory()
            obj_.build(child_)
            self.Branch.append(obj_)
            obj_.original_tagname_ = 'Branch'
# end class BranchType


class ProductTree(GeneratedsSuper):
    """Neutral product tree to streamline product entries that can be
    referenced elsewhere in the document. The end of each branch
    ("FullProductName") represents a referrenceable product.This is
    to ensure that each FullProductName uses a unique ProductID
    value.This is to ensure that each Group uses a unique GroupID
    value.A key to reference a specific product.An instance of the
    ProductKey used to define a relationship product.An instance of
    the ProductKey used to define a related product.An instance of
    the ProductKey used to define a product group membership list."""
    subclass = None
    superclass = None
    def __init__(self, Branch=None, FullProductName=None, Relationship=None, ProductGroups=None):
        self.original_tagname_ = None
        if Branch is None:
            self.Branch = []
        else:
            self.Branch = Branch
        if FullProductName is None:
            self.FullProductName = []
        else:
            self.FullProductName = FullProductName
        if Relationship is None:
            self.Relationship = []
        else:
            self.Relationship = Relationship
        self.ProductGroups = ProductGroups
    def factory(*args_, **kwargs_):
        if ProductTree.subclass:
            return ProductTree.subclass(*args_, **kwargs_)
        else:
            return ProductTree(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Branch(self): return self.Branch
    def set_Branch(self, Branch): self.Branch = Branch
    def add_Branch(self, value): self.Branch.append(value)
    def insert_Branch_at(self, index, value): self.Branch.insert(index, value)
    def replace_Branch_at(self, index, value): self.Branch[index] = value
    def get_FullProductName(self): return self.FullProductName
    def set_FullProductName(self, FullProductName): self.FullProductName = FullProductName
    def add_FullProductName(self, value): self.FullProductName.append(value)
    def insert_FullProductName_at(self, index, value): self.FullProductName.insert(index, value)
    def replace_FullProductName_at(self, index, value): self.FullProductName[index] = value
    def get_Relationship(self): return self.Relationship
    def set_Relationship(self, Relationship): self.Relationship = Relationship
    def add_Relationship(self, value): self.Relationship.append(value)
    def insert_Relationship_at(self, index, value): self.Relationship.insert(index, value)
    def replace_Relationship_at(self, index, value): self.Relationship[index] = value
    def get_ProductGroups(self): return self.ProductGroups
    def set_ProductGroups(self, ProductGroups): self.ProductGroups = ProductGroups
    def hasContent_(self):
        if (
            self.Branch or
            self.FullProductName or
            self.Relationship or
            self.ProductGroups is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='ProductTree', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1" xmlns:prod="http://www.icasi.org/CVRF/schema/prod/1.1" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProductTree')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='ProductTree', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='ProductTree'):
        pass
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='ProductTree', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Branch_ in self.Branch:
            Branch_.export(outfile, level, namespace_, name_='Branch', pretty_print=pretty_print)
        for FullProductName_ in self.FullProductName:
            FullProductName_.export(outfile, level, namespace_='prod:', name_='FullProductName', pretty_print=pretty_print)
        for Relationship_ in self.Relationship:
            Relationship_.export(outfile, level, namespace_, name_='Relationship', pretty_print=pretty_print)
        if self.ProductGroups is not None:
            self.ProductGroups.export(outfile, level, namespace_, name_='ProductGroups', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ProductTree'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Branch=[\n')
        level += 1
        for Branch_ in self.Branch:
            showIndent(outfile, level)
            outfile.write('model_.BranchType(\n')
            Branch_.exportLiteral(outfile, level, name_='BranchType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('FullProductName=[\n')
        level += 1
        for FullProductName_ in self.FullProductName:
            showIndent(outfile, level)
            outfile.write('model_.FullProductName(\n')
            FullProductName_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Relationship=[\n')
        level += 1
        for Relationship_ in self.Relationship:
            showIndent(outfile, level)
            outfile.write('model_.RelationshipType(\n')
            Relationship_.exportLiteral(outfile, level, name_='RelationshipType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.ProductGroups is not None:
            showIndent(outfile, level)
            outfile.write('ProductGroups=model_.ProductGroupsType(\n')
            self.ProductGroups.exportLiteral(outfile, level, name_='ProductGroups')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Branch':
            obj_ = BranchType.factory()
            obj_.build(child_)
            self.Branch.append(obj_)
            obj_.original_tagname_ = 'Branch'
        elif nodeName_ == 'FullProductName':
            obj_ = FullProductName.factory()
            obj_.build(child_)
            self.FullProductName.append(obj_)
            obj_.original_tagname_ = 'FullProductName'
        elif nodeName_ == 'Relationship':
            obj_ = RelationshipType.factory()
            obj_.build(child_)
            self.Relationship.append(obj_)
            obj_.original_tagname_ = 'Relationship'
        elif nodeName_ == 'ProductGroups':
            obj_ = ProductGroupsType.factory()
            obj_.build(child_)
            self.ProductGroups = obj_
            obj_.original_tagname_ = 'ProductGroups'
# end class ProductTree


class FullProductName(GeneratedsSuper):
    """Endpoint of product tree - this is an actual product entry. The
    string represents the friendly product name (i.e. the way it
    would be printed in other publications)A value that uniquely
    identifies this Product entry in the scope of this document.
    Whenever a reference to this Product entry is needed anywhere in
    this document, its unique ID will be referenced.The Common
    Platform Enumeration (CPE) attribute refers to a method for
    naming platforms. The structure for CPE is described at
    http://cpe.mitre.org."""
    subclass = None
    superclass = None
    def __init__(self, CPE=None, ProductID=None, valueOf_=None):
        self.original_tagname_ = None
        self.CPE = _cast(None, CPE)
        self.ProductID = _cast(None, ProductID)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if FullProductName.subclass:
            return FullProductName.subclass(*args_, **kwargs_)
        else:
            return FullProductName(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CPE(self): return self.CPE
    def set_CPE(self, CPE): self.CPE = CPE
    def get_ProductID(self): return self.ProductID
    def set_ProductID(self, ProductID): self.ProductID = ProductID
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='FullProductName', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FullProductName')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='FullProductName', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='FullProductName'):
        if self.CPE is not None and 'CPE' not in already_processed:
            already_processed.add('CPE')
            outfile.write(' CPE=%s' % (quote_attrib(self.CPE), ))
        if self.ProductID is not None and 'ProductID' not in already_processed:
            already_processed.add('ProductID')
            outfile.write(' ProductID=%s' % (self.gds_format_string(quote_attrib(self.ProductID).encode(ExternalEncoding), input_name='ProductID'), ))
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='FullProductName', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='FullProductName'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.CPE is not None and 'CPE' not in already_processed:
            already_processed.add('CPE')
            showIndent(outfile, level)
            outfile.write('CPE=%s,\n' % (self.CPE,))
        if self.ProductID is not None and 'ProductID' not in already_processed:
            already_processed.add('ProductID')
            showIndent(outfile, level)
            outfile.write('ProductID="%s",\n' % (self.ProductID,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('CPE', node)
        if value is not None and 'CPE' not in already_processed:
            already_processed.add('CPE')
            self.CPE = value
        value = find_attr_value_('ProductID', node)
        if value is not None and 'ProductID' not in already_processed:
            already_processed.add('ProductID')
            self.ProductID = value
            self.ProductID = ' '.join(self.ProductID.split())
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class FullProductName


class DocumentTitleType(localizedNormalizedString):
    subclass = None
    superclass = localizedNormalizedString
    def __init__(self, lang='en', valueOf_=None):
        self.original_tagname_ = None
        super(DocumentTitleType, self).__init__(lang, valueOf_, )
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if DocumentTitleType.subclass:
            return DocumentTitleType.subclass(*args_, **kwargs_)
        else:
            return DocumentTitleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(DocumentTitleType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='DocumentTitleType', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DocumentTitleType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='DocumentTitleType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='DocumentTitleType'):
        super(DocumentTitleType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DocumentTitleType')
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='DocumentTitleType', fromsubclass_=False, pretty_print=True):
        super(DocumentTitleType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='DocumentTitleType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DocumentTitleType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DocumentTitleType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DocumentTitleType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DocumentTitleType


class DocumentTypeType(localizedNormalizedString):
    subclass = None
    superclass = localizedNormalizedString
    def __init__(self, lang='en', valueOf_=None):
        self.original_tagname_ = None
        super(DocumentTypeType, self).__init__(lang, valueOf_, )
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if DocumentTypeType.subclass:
            return DocumentTypeType.subclass(*args_, **kwargs_)
        else:
            return DocumentTypeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(DocumentTypeType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='DocumentTypeType', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DocumentTypeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='DocumentTypeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='DocumentTypeType'):
        super(DocumentTypeType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DocumentTypeType')
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='DocumentTypeType', fromsubclass_=False, pretty_print=True):
        super(DocumentTypeType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='DocumentTypeType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DocumentTypeType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DocumentTypeType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DocumentTypeType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DocumentTypeType


class DocumentPublisherType(GeneratedsSuper):
    """Type is an enumerated list containing an array of different document
    publisher types.Vendor ID is a unique identifier (OID) that a
    vendor uses as issued by FIRST under the auspices of IETF."""
    subclass = None
    superclass = None
    def __init__(self, VendorID=None, Type=None, ContactDetails=None, IssuingAuthority=None):
        self.original_tagname_ = None
        self.VendorID = _cast(None, VendorID)
        self.Type = _cast(None, Type)
        self.ContactDetails = ContactDetails
        self.IssuingAuthority = IssuingAuthority
    def factory(*args_, **kwargs_):
        if DocumentPublisherType.subclass:
            return DocumentPublisherType.subclass(*args_, **kwargs_)
        else:
            return DocumentPublisherType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ContactDetails(self): return self.ContactDetails
    def set_ContactDetails(self, ContactDetails): self.ContactDetails = ContactDetails
    def get_IssuingAuthority(self): return self.IssuingAuthority
    def set_IssuingAuthority(self, IssuingAuthority): self.IssuingAuthority = IssuingAuthority
    def get_VendorID(self): return self.VendorID
    def set_VendorID(self, VendorID): self.VendorID = VendorID
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def hasContent_(self):
        if (
            self.ContactDetails is not None or
            self.IssuingAuthority is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='DocumentPublisherType', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DocumentPublisherType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='DocumentPublisherType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='DocumentPublisherType'):
        if self.VendorID is not None and 'VendorID' not in already_processed:
            already_processed.add('VendorID')
            outfile.write(' VendorID=%s' % (self.gds_format_string(quote_attrib(self.VendorID).encode(ExternalEncoding), input_name='VendorID'), ))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            outfile.write(' Type=%s' % (quote_attrib(self.Type), ))
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='DocumentPublisherType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ContactDetails is not None:
            self.ContactDetails.export(outfile, level, namespace_, name_='ContactDetails', pretty_print=pretty_print)
        if self.IssuingAuthority is not None:
            self.IssuingAuthority.export(outfile, level, namespace_, name_='IssuingAuthority', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='DocumentPublisherType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.VendorID is not None and 'VendorID' not in already_processed:
            already_processed.add('VendorID')
            showIndent(outfile, level)
            outfile.write('VendorID="%s",\n' % (self.VendorID,))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            showIndent(outfile, level)
            outfile.write('Type=%s,\n' % (self.Type,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ContactDetails is not None:
            showIndent(outfile, level)
            outfile.write('ContactDetails=model_.ContactDetailsType(\n')
            self.ContactDetails.exportLiteral(outfile, level, name_='ContactDetails')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.IssuingAuthority is not None:
            showIndent(outfile, level)
            outfile.write('IssuingAuthority=model_.IssuingAuthorityType(\n')
            self.IssuingAuthority.exportLiteral(outfile, level, name_='IssuingAuthority')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('VendorID', node)
        if value is not None and 'VendorID' not in already_processed:
            already_processed.add('VendorID')
            self.VendorID = value
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            self.Type = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ContactDetails':
            obj_ = ContactDetailsType.factory()
            obj_.build(child_)
            self.ContactDetails = obj_
            obj_.original_tagname_ = 'ContactDetails'
        elif nodeName_ == 'IssuingAuthority':
            obj_ = IssuingAuthorityType.factory()
            obj_.build(child_)
            self.IssuingAuthority = obj_
            obj_.original_tagname_ = 'IssuingAuthority'
# end class DocumentPublisherType


class ContactDetailsType(localizedString):
    subclass = None
    superclass = localizedString
    def __init__(self, lang='en', valueOf_=None):
        self.original_tagname_ = None
        super(ContactDetailsType, self).__init__(lang, valueOf_, )
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if ContactDetailsType.subclass:
            return ContactDetailsType.subclass(*args_, **kwargs_)
        else:
            return ContactDetailsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(ContactDetailsType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='ContactDetailsType', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ContactDetailsType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='ContactDetailsType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='ContactDetailsType'):
        super(ContactDetailsType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ContactDetailsType')
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='ContactDetailsType', fromsubclass_=False, pretty_print=True):
        super(ContactDetailsType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='ContactDetailsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(ContactDetailsType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ContactDetailsType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ContactDetailsType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ContactDetailsType


class IssuingAuthorityType(localizedString):
    subclass = None
    superclass = localizedString
    def __init__(self, lang='en', valueOf_=None):
        self.original_tagname_ = None
        super(IssuingAuthorityType, self).__init__(lang, valueOf_, )
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if IssuingAuthorityType.subclass:
            return IssuingAuthorityType.subclass(*args_, **kwargs_)
        else:
            return IssuingAuthorityType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(IssuingAuthorityType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='IssuingAuthorityType', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IssuingAuthorityType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='IssuingAuthorityType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='IssuingAuthorityType'):
        super(IssuingAuthorityType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='IssuingAuthorityType')
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='IssuingAuthorityType', fromsubclass_=False, pretty_print=True):
        super(IssuingAuthorityType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='IssuingAuthorityType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(IssuingAuthorityType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(IssuingAuthorityType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(IssuingAuthorityType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class IssuingAuthorityType


class DocumentTrackingType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Identification=None, Status=None, Version=None, RevisionHistory=None, InitialReleaseDate=None, CurrentReleaseDate=None, Generator=None):
        self.original_tagname_ = None
        self.Identification = Identification
        self.Status = Status
        self.validate_DocumentStatusEnumType(self.Status)
        self.Version = Version
        self.validate_revisionNumber(self.Version)
        self.RevisionHistory = RevisionHistory
        if isinstance(InitialReleaseDate, basestring):
            initvalue_ = datetime_.datetime.strptime(InitialReleaseDate, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = InitialReleaseDate
        self.InitialReleaseDate = initvalue_
        if isinstance(CurrentReleaseDate, basestring):
            initvalue_ = datetime_.datetime.strptime(CurrentReleaseDate, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = CurrentReleaseDate
        self.CurrentReleaseDate = initvalue_
        self.Generator = Generator
    def factory(*args_, **kwargs_):
        if DocumentTrackingType.subclass:
            return DocumentTrackingType.subclass(*args_, **kwargs_)
        else:
            return DocumentTrackingType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Identification(self): return self.Identification
    def set_Identification(self, Identification): self.Identification = Identification
    def get_Status(self): return self.Status
    def set_Status(self, Status): self.Status = Status
    def get_Version(self): return self.Version
    def set_Version(self, Version): self.Version = Version
    def get_RevisionHistory(self): return self.RevisionHistory
    def set_RevisionHistory(self, RevisionHistory): self.RevisionHistory = RevisionHistory
    def get_InitialReleaseDate(self): return self.InitialReleaseDate
    def set_InitialReleaseDate(self, InitialReleaseDate): self.InitialReleaseDate = InitialReleaseDate
    def get_CurrentReleaseDate(self): return self.CurrentReleaseDate
    def set_CurrentReleaseDate(self, CurrentReleaseDate): self.CurrentReleaseDate = CurrentReleaseDate
    def get_Generator(self): return self.Generator
    def set_Generator(self, Generator): self.Generator = Generator
    def validate_DocumentStatusEnumType(self, value):
        # Validate type DocumentStatusEnumType, a restriction on xs:normalizedString.
        if value is not None and Validate_simpletypes_:
            enumerations = ['Draft', 'Interim', 'Final']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on DocumentStatusEnumType' % {"value" : value.encode("utf-8")} )
    def validate_revisionNumber(self, value):
        # Validate type revisionNumber, a restriction on xs:token.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_revisionNumber_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_revisionNumber_patterns_, ))
    validate_revisionNumber_patterns_ = [['^(0|[1-9][0-9]*)(\\.(0|[1-9][0-9]*)){0,3}$']]
    def hasContent_(self):
        if (
            self.Identification is not None or
            self.Status is not None or
            self.Version is not None or
            self.RevisionHistory is not None or
            self.InitialReleaseDate is not None or
            self.CurrentReleaseDate is not None or
            self.Generator is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='DocumentTrackingType', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1" xmlns:cvrf-common="http://www.icasi.org/CVRF/schema/common/1.1" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DocumentTrackingType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='DocumentTrackingType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='DocumentTrackingType'):
        pass
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='DocumentTrackingType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Identification is not None:
            self.Identification.export(outfile, level, namespace_, name_='Identification', pretty_print=pretty_print)
        if self.Status is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStatus>%s</%sStatus>%s' % (namespace_, self.gds_format_string(quote_xml(self.Status).encode(ExternalEncoding), input_name='Status'), namespace_, eol_))
        if self.Version is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVersion>%s</%sVersion>%s' % (namespace_, self.gds_format_string(quote_xml(self.Version).encode(ExternalEncoding), input_name='Version'), namespace_, eol_))
        if self.RevisionHistory is not None:
            self.RevisionHistory.export(outfile, level, namespace_, name_='RevisionHistory', pretty_print=pretty_print)
        if self.InitialReleaseDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sInitialReleaseDate>%s</%sInitialReleaseDate>%s' % (namespace_, self.gds_format_datetime(self.InitialReleaseDate, input_name='InitialReleaseDate'), namespace_, eol_))
        if self.CurrentReleaseDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCurrentReleaseDate>%s</%sCurrentReleaseDate>%s' % (namespace_, self.gds_format_datetime(self.CurrentReleaseDate, input_name='CurrentReleaseDate'), namespace_, eol_))
        if self.Generator is not None:
            self.Generator.export(outfile, level, namespace_, name_='Generator', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='DocumentTrackingType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Identification is not None:
            showIndent(outfile, level)
            outfile.write('Identification=model_.IdentificationType(\n')
            self.Identification.exportLiteral(outfile, level, name_='Identification')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Status is not None:
            showIndent(outfile, level)
            outfile.write('Status=%s,\n' % quote_python(self.Status).encode(ExternalEncoding))
        if self.Version is not None:
            showIndent(outfile, level)
            outfile.write('Version=%s,\n' % quote_python(self.Version).encode(ExternalEncoding))
        if self.RevisionHistory is not None:
            showIndent(outfile, level)
            outfile.write('RevisionHistory=model_.RevisionHistoryType(\n')
            self.RevisionHistory.exportLiteral(outfile, level, name_='RevisionHistory')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.InitialReleaseDate is not None:
            showIndent(outfile, level)
            outfile.write('InitialReleaseDate=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.InitialReleaseDate, input_name='InitialReleaseDate'))
        if self.CurrentReleaseDate is not None:
            showIndent(outfile, level)
            outfile.write('CurrentReleaseDate=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.CurrentReleaseDate, input_name='CurrentReleaseDate'))
        if self.Generator is not None:
            showIndent(outfile, level)
            outfile.write('Generator=model_.GeneratorType(\n')
            self.Generator.exportLiteral(outfile, level, name_='Generator')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Identification':
            obj_ = IdentificationType.factory()
            obj_.build(child_)
            self.Identification = obj_
            obj_.original_tagname_ = 'Identification'
        elif nodeName_ == 'Status':
            Status_ = child_.text
            Status_ = self.gds_validate_string(Status_, node, 'Status')
            self.Status = Status_
            self.validate_DocumentStatusEnumType(self.Status)    # validate type DocumentStatusEnumType
        elif nodeName_ == 'Version':
            Version_ = child_.text
            Version_ = re_.sub(String_cleanup_pat_, " ", Version_).strip()
            Version_ = self.gds_validate_string(Version_, node, 'Version')
            self.Version = Version_
            self.validate_revisionNumber(self.Version)    # validate type revisionNumber
        elif nodeName_ == 'RevisionHistory':
            obj_ = RevisionHistoryType.factory()
            obj_.build(child_)
            self.RevisionHistory = obj_
            obj_.original_tagname_ = 'RevisionHistory'
        elif nodeName_ == 'InitialReleaseDate':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.InitialReleaseDate = dval_
        elif nodeName_ == 'CurrentReleaseDate':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.CurrentReleaseDate = dval_
        elif nodeName_ == 'Generator':
            obj_ = GeneratorType.factory()
            obj_.build(child_)
            self.Generator = obj_
            obj_.original_tagname_ = 'Generator'
# end class DocumentTrackingType


class IdentificationType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, Alias=None):
        self.original_tagname_ = None
        self.ID = ID
        if Alias is None:
            self.Alias = []
        else:
            self.Alias = Alias
    def factory(*args_, **kwargs_):
        if IdentificationType.subclass:
            return IdentificationType.subclass(*args_, **kwargs_)
        else:
            return IdentificationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_Alias(self): return self.Alias
    def set_Alias(self, Alias): self.Alias = Alias
    def add_Alias(self, value): self.Alias.append(value)
    def insert_Alias_at(self, index, value): self.Alias.insert(index, value)
    def replace_Alias_at(self, index, value): self.Alias[index] = value
    def hasContent_(self):
        if (
            self.ID is not None or
            self.Alias
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='IdentificationType', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IdentificationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='IdentificationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='IdentificationType'):
        pass
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='IdentificationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ID is not None:
            self.ID.export(outfile, level, namespace_, name_='ID', pretty_print=pretty_print)
        for Alias_ in self.Alias:
            Alias_.export(outfile, level, namespace_, name_='Alias', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='IdentificationType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ID is not None:
            showIndent(outfile, level)
            outfile.write('ID=model_.IDType(\n')
            self.ID.exportLiteral(outfile, level, name_='ID')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Alias=[\n')
        level += 1
        for Alias_ in self.Alias:
            showIndent(outfile, level)
            outfile.write('model_.AliasType(\n')
            Alias_.exportLiteral(outfile, level, name_='AliasType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ID':
            obj_ = IDType.factory()
            obj_.build(child_)
            self.ID = obj_
            obj_.original_tagname_ = 'ID'
        elif nodeName_ == 'Alias':
            obj_ = AliasType.factory()
            obj_.build(child_)
            self.Alias.append(obj_)
            obj_.original_tagname_ = 'Alias'
# end class IdentificationType


class IDType(localizedString):
    subclass = None
    superclass = localizedString
    def __init__(self, lang='en', valueOf_=None):
        self.original_tagname_ = None
        super(IDType, self).__init__(lang, valueOf_, )
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if IDType.subclass:
            return IDType.subclass(*args_, **kwargs_)
        else:
            return IDType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(IDType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='IDType', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IDType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='IDType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='IDType'):
        super(IDType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='IDType')
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='IDType', fromsubclass_=False, pretty_print=True):
        super(IDType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='IDType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(IDType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(IDType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(IDType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class IDType


class AliasType(localizedString):
    subclass = None
    superclass = localizedString
    def __init__(self, lang='en', valueOf_=None):
        self.original_tagname_ = None
        super(AliasType, self).__init__(lang, valueOf_, )
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if AliasType.subclass:
            return AliasType.subclass(*args_, **kwargs_)
        else:
            return AliasType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(AliasType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='AliasType', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AliasType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='AliasType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='AliasType'):
        super(AliasType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AliasType')
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='AliasType', fromsubclass_=False, pretty_print=True):
        super(AliasType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='AliasType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(AliasType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AliasType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(AliasType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AliasType


class RevisionHistoryType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Revision=None):
        self.original_tagname_ = None
        if Revision is None:
            self.Revision = []
        else:
            self.Revision = Revision
    def factory(*args_, **kwargs_):
        if RevisionHistoryType.subclass:
            return RevisionHistoryType.subclass(*args_, **kwargs_)
        else:
            return RevisionHistoryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Revision(self): return self.Revision
    def set_Revision(self, Revision): self.Revision = Revision
    def add_Revision(self, value): self.Revision.append(value)
    def insert_Revision_at(self, index, value): self.Revision.insert(index, value)
    def replace_Revision_at(self, index, value): self.Revision[index] = value
    def hasContent_(self):
        if (
            self.Revision
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='RevisionHistoryType', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RevisionHistoryType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='RevisionHistoryType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='RevisionHistoryType'):
        pass
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='RevisionHistoryType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Revision_ in self.Revision:
            Revision_.export(outfile, level, namespace_, name_='Revision', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='RevisionHistoryType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Revision=[\n')
        level += 1
        for Revision_ in self.Revision:
            showIndent(outfile, level)
            outfile.write('model_.RevisionType(\n')
            Revision_.exportLiteral(outfile, level, name_='RevisionType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Revision':
            obj_ = RevisionType.factory()
            obj_.build(child_)
            self.Revision.append(obj_)
            obj_.original_tagname_ = 'Revision'
# end class RevisionHistoryType


class RevisionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Number=None, Date=None, Description=None):
        self.original_tagname_ = None
        self.Number = Number
        self.validate_revisionNumber(self.Number)
        if isinstance(Date, basestring):
            initvalue_ = datetime_.datetime.strptime(Date, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = Date
        self.Date = initvalue_
        self.Description = Description
    def factory(*args_, **kwargs_):
        if RevisionType.subclass:
            return RevisionType.subclass(*args_, **kwargs_)
        else:
            return RevisionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Number(self): return self.Number
    def set_Number(self, Number): self.Number = Number
    def get_Date(self): return self.Date
    def set_Date(self, Date): self.Date = Date
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def validate_revisionNumber(self, value):
        # Validate type revisionNumber, a restriction on xs:token.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_revisionNumber_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_revisionNumber_patterns_, ))
    validate_revisionNumber_patterns_ = [['^(0|[1-9][0-9]*)(\\.(0|[1-9][0-9]*)){0,3}$']]
    def hasContent_(self):
        if (
            self.Number is not None or
            self.Date is not None or
            self.Description is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='RevisionType', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1" xmlns:cvrf-common="http://www.icasi.org/CVRF/schema/common/1.1" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RevisionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='RevisionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='RevisionType'):
        pass
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='RevisionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Number is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNumber>%s</%sNumber>%s' % (namespace_, self.gds_format_string(quote_xml(self.Number).encode(ExternalEncoding), input_name='Number'), namespace_, eol_))
        if self.Date is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDate>%s</%sDate>%s' % (namespace_, self.gds_format_datetime(self.Date, input_name='Date'), namespace_, eol_))
        if self.Description is not None:
            self.Description.export(outfile, level, namespace_, name_='Description', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='RevisionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Number is not None:
            showIndent(outfile, level)
            outfile.write('Number=%s,\n' % quote_python(self.Number).encode(ExternalEncoding))
        if self.Date is not None:
            showIndent(outfile, level)
            outfile.write('Date=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.Date, input_name='Date'))
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('Description=model_.DescriptionType(\n')
            self.Description.exportLiteral(outfile, level, name_='Description')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Number':
            Number_ = child_.text
            Number_ = re_.sub(String_cleanup_pat_, " ", Number_).strip()
            Number_ = self.gds_validate_string(Number_, node, 'Number')
            self.Number = Number_
            self.validate_revisionNumber(self.Number)    # validate type revisionNumber
        elif nodeName_ == 'Date':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.Date = dval_
        elif nodeName_ == 'Description':
            obj_ = DescriptionType.factory()
            obj_.build(child_)
            self.Description = obj_
            obj_.original_tagname_ = 'Description'
# end class RevisionType


class DescriptionType(localizedString):
    subclass = None
    superclass = localizedString
    def __init__(self, lang='en', valueOf_=None):
        self.original_tagname_ = None
        super(DescriptionType, self).__init__(lang, valueOf_, )
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if DescriptionType.subclass:
            return DescriptionType.subclass(*args_, **kwargs_)
        else:
            return DescriptionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(DescriptionType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='DescriptionType', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DescriptionType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='DescriptionType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='DescriptionType'):
        super(DescriptionType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DescriptionType')
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='DescriptionType', fromsubclass_=False, pretty_print=True):
        super(DescriptionType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='DescriptionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DescriptionType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DescriptionType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DescriptionType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DescriptionType


class GeneratorType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Engine=None, Date=None):
        self.original_tagname_ = None
        self.Engine = Engine
        if isinstance(Date, basestring):
            initvalue_ = datetime_.datetime.strptime(Date, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = Date
        self.Date = initvalue_
    def factory(*args_, **kwargs_):
        if GeneratorType.subclass:
            return GeneratorType.subclass(*args_, **kwargs_)
        else:
            return GeneratorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Engine(self): return self.Engine
    def set_Engine(self, Engine): self.Engine = Engine
    def get_Date(self): return self.Date
    def set_Date(self, Date): self.Date = Date
    def hasContent_(self):
        if (
            self.Engine is not None or
            self.Date is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='GeneratorType', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GeneratorType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='GeneratorType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='GeneratorType'):
        pass
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='GeneratorType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Engine is not None:
            self.Engine.export(outfile, level, namespace_, name_='Engine', pretty_print=pretty_print)
        if self.Date is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDate>%s</%sDate>%s' % (namespace_, self.gds_format_datetime(self.Date, input_name='Date'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='GeneratorType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Engine is not None:
            showIndent(outfile, level)
            outfile.write('Engine=model_.EngineType(\n')
            self.Engine.exportLiteral(outfile, level, name_='Engine')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Date is not None:
            showIndent(outfile, level)
            outfile.write('Date=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.Date, input_name='Date'))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Engine':
            obj_ = EngineType.factory()
            obj_.build(child_)
            self.Engine = obj_
            obj_.original_tagname_ = 'Engine'
        elif nodeName_ == 'Date':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.Date = dval_
# end class GeneratorType


class EngineType(localizedString):
    subclass = None
    superclass = localizedString
    def __init__(self, lang='en', valueOf_=None):
        self.original_tagname_ = None
        super(EngineType, self).__init__(lang, valueOf_, )
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if EngineType.subclass:
            return EngineType.subclass(*args_, **kwargs_)
        else:
            return EngineType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(EngineType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='EngineType', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EngineType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='EngineType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='EngineType'):
        super(EngineType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='EngineType')
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='EngineType', fromsubclass_=False, pretty_print=True):
        super(EngineType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='EngineType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(EngineType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(EngineType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(EngineType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EngineType


class DocumentNotesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Note=None):
        self.original_tagname_ = None
        if Note is None:
            self.Note = []
        else:
            self.Note = Note
    def factory(*args_, **kwargs_):
        if DocumentNotesType.subclass:
            return DocumentNotesType.subclass(*args_, **kwargs_)
        else:
            return DocumentNotesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Note(self): return self.Note
    def set_Note(self, Note): self.Note = Note
    def add_Note(self, value): self.Note.append(value)
    def insert_Note_at(self, index, value): self.Note.insert(index, value)
    def replace_Note_at(self, index, value): self.Note[index] = value
    def hasContent_(self):
        if (
            self.Note
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='DocumentNotesType', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DocumentNotesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='DocumentNotesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='DocumentNotesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='DocumentNotesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Note_ in self.Note:
            Note_.export(outfile, level, namespace_, name_='Note', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='DocumentNotesType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Note=[\n')
        level += 1
        for Note_ in self.Note:
            showIndent(outfile, level)
            outfile.write('model_.NoteType(\n')
            Note_.exportLiteral(outfile, level, name_='NoteType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Note':
            obj_ = NoteType.factory()
            obj_.build(child_)
            self.Note.append(obj_)
            obj_.original_tagname_ = 'Note'
# end class DocumentNotesType


class NoteType(localizedString):
    """Title should be a concise description of what is contained in this
    specific note.Audience will indicate who is intended to read the
    note.Type of content within this note.Ordinal is a locally
    significant integral counter indexed from 1 used to track notes."""
    subclass = None
    superclass = localizedString
    def __init__(self, lang='en', Ordinal=None, Audience=None, Type=None, Title=None, valueOf_=None):
        self.original_tagname_ = None
        super(NoteType, self).__init__(lang, valueOf_, )
        self.Ordinal = _cast(int, Ordinal)
        self.Audience = _cast(None, Audience)
        self.Type = _cast(None, Type)
        self.Title = _cast(None, Title)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if NoteType.subclass:
            return NoteType.subclass(*args_, **kwargs_)
        else:
            return NoteType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Ordinal(self): return self.Ordinal
    def set_Ordinal(self, Ordinal): self.Ordinal = Ordinal
    def get_Audience(self): return self.Audience
    def set_Audience(self, Audience): self.Audience = Audience
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_Title(self): return self.Title
    def set_Title(self, Title): self.Title = Title
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(NoteType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='NoteType', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NoteType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='NoteType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='NoteType'):
        super(NoteType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='NoteType')
        if self.Ordinal is not None and 'Ordinal' not in already_processed:
            already_processed.add('Ordinal')
            outfile.write(' Ordinal="%s"' % self.gds_format_integer(self.Ordinal, input_name='Ordinal'))
        if self.Audience is not None and 'Audience' not in already_processed:
            already_processed.add('Audience')
            outfile.write(' Audience=%s' % (self.gds_format_string(quote_attrib(self.Audience).encode(ExternalEncoding), input_name='Audience'), ))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            outfile.write(' Type=%s' % (quote_attrib(self.Type), ))
        if self.Title is not None and 'Title' not in already_processed:
            already_processed.add('Title')
            outfile.write(' Title=%s' % (self.gds_format_string(quote_attrib(self.Title).encode(ExternalEncoding), input_name='Title'), ))
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='NoteType', fromsubclass_=False, pretty_print=True):
        super(NoteType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='NoteType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Ordinal is not None and 'Ordinal' not in already_processed:
            already_processed.add('Ordinal')
            showIndent(outfile, level)
            outfile.write('Ordinal=%d,\n' % (self.Ordinal,))
        if self.Audience is not None and 'Audience' not in already_processed:
            already_processed.add('Audience')
            showIndent(outfile, level)
            outfile.write('Audience="%s",\n' % (self.Audience,))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            showIndent(outfile, level)
            outfile.write('Type=%s,\n' % (self.Type,))
        if self.Title is not None and 'Title' not in already_processed:
            already_processed.add('Title')
            showIndent(outfile, level)
            outfile.write('Title="%s",\n' % (self.Title,))
        super(NoteType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(NoteType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Ordinal', node)
        if value is not None and 'Ordinal' not in already_processed:
            already_processed.add('Ordinal')
            try:
                self.Ordinal = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.Ordinal <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('Audience', node)
        if value is not None and 'Audience' not in already_processed:
            already_processed.add('Audience')
            self.Audience = value
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            self.Type = value
        value = find_attr_value_('Title', node)
        if value is not None and 'Title' not in already_processed:
            already_processed.add('Title')
            self.Title = value
        super(NoteType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class NoteType


class DocumentDistributionType(localizedString):
    subclass = None
    superclass = localizedString
    def __init__(self, lang='en', valueOf_=None):
        self.original_tagname_ = None
        super(DocumentDistributionType, self).__init__(lang, valueOf_, )
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if DocumentDistributionType.subclass:
            return DocumentDistributionType.subclass(*args_, **kwargs_)
        else:
            return DocumentDistributionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(DocumentDistributionType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='DocumentDistributionType', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DocumentDistributionType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='DocumentDistributionType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='DocumentDistributionType'):
        super(DocumentDistributionType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DocumentDistributionType')
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='DocumentDistributionType', fromsubclass_=False, pretty_print=True):
        super(DocumentDistributionType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='DocumentDistributionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DocumentDistributionType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DocumentDistributionType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DocumentDistributionType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DocumentDistributionType


class AggregateSeverityType(localizedString):
    """URL of the namespace from which the Aggregate Severity is taken."""
    subclass = None
    superclass = localizedString
    def __init__(self, lang='en', Namespace=None, valueOf_=None):
        self.original_tagname_ = None
        super(AggregateSeverityType, self).__init__(lang, valueOf_, )
        self.Namespace = _cast(None, Namespace)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if AggregateSeverityType.subclass:
            return AggregateSeverityType.subclass(*args_, **kwargs_)
        else:
            return AggregateSeverityType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Namespace(self): return self.Namespace
    def set_Namespace(self, Namespace): self.Namespace = Namespace
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(AggregateSeverityType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='AggregateSeverityType', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AggregateSeverityType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='AggregateSeverityType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='AggregateSeverityType'):
        super(AggregateSeverityType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AggregateSeverityType')
        if self.Namespace is not None and 'Namespace' not in already_processed:
            already_processed.add('Namespace')
            outfile.write(' Namespace=%s' % (self.gds_format_string(quote_attrib(self.Namespace).encode(ExternalEncoding), input_name='Namespace'), ))
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='AggregateSeverityType', fromsubclass_=False, pretty_print=True):
        super(AggregateSeverityType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='AggregateSeverityType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Namespace is not None and 'Namespace' not in already_processed:
            already_processed.add('Namespace')
            showIndent(outfile, level)
            outfile.write('Namespace="%s",\n' % (self.Namespace,))
        super(AggregateSeverityType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AggregateSeverityType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Namespace', node)
        if value is not None and 'Namespace' not in already_processed:
            already_processed.add('Namespace')
            self.Namespace = value
        super(AggregateSeverityType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AggregateSeverityType


class DocumentReferencesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Reference=None):
        self.original_tagname_ = None
        if Reference is None:
            self.Reference = []
        else:
            self.Reference = Reference
    def factory(*args_, **kwargs_):
        if DocumentReferencesType.subclass:
            return DocumentReferencesType.subclass(*args_, **kwargs_)
        else:
            return DocumentReferencesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Reference(self): return self.Reference
    def set_Reference(self, Reference): self.Reference = Reference
    def add_Reference(self, value): self.Reference.append(value)
    def insert_Reference_at(self, index, value): self.Reference.insert(index, value)
    def replace_Reference_at(self, index, value): self.Reference[index] = value
    def hasContent_(self):
        if (
            self.Reference
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='DocumentReferencesType', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DocumentReferencesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='DocumentReferencesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='DocumentReferencesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='DocumentReferencesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Reference_ in self.Reference:
            Reference_.export(outfile, level, namespace_, name_='Reference', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='DocumentReferencesType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Reference=[\n')
        level += 1
        for Reference_ in self.Reference:
            showIndent(outfile, level)
            outfile.write('model_.ReferenceType(\n')
            Reference_.exportLiteral(outfile, level, name_='ReferenceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Reference':
            obj_ = ReferenceType.factory()
            obj_.build(child_)
            self.Reference.append(obj_)
            obj_.original_tagname_ = 'Reference'
# end class DocumentReferencesType


class ReferenceType(GeneratedsSuper):
    """Enumerated type value of reference relative to this document."""
    subclass = None
    superclass = None
    def __init__(self, Type='External', URL=None, Description=None):
        self.original_tagname_ = None
        self.Type = _cast(None, Type)
        self.URL = URL
        self.Description = Description
    def factory(*args_, **kwargs_):
        if ReferenceType.subclass:
            return ReferenceType.subclass(*args_, **kwargs_)
        else:
            return ReferenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_URL(self): return self.URL
    def set_URL(self, URL): self.URL = URL
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def hasContent_(self):
        if (
            self.URL is not None or
            self.Description is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='ReferenceType', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReferenceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='ReferenceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='ReferenceType'):
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            outfile.write(' Type=%s' % (quote_attrib(self.Type), ))
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='ReferenceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.URL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sURL>%s</%sURL>%s' % (namespace_, self.gds_format_string(quote_xml(self.URL).encode(ExternalEncoding), input_name='URL'), namespace_, eol_))
        if self.Description is not None:
            self.Description.export(outfile, level, namespace_, name_='Description', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ReferenceType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            showIndent(outfile, level)
            outfile.write('Type=%s,\n' % (self.Type,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.URL is not None:
            showIndent(outfile, level)
            outfile.write('URL=%s,\n' % quote_python(self.URL).encode(ExternalEncoding))
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('Description=model_.DescriptionType1(\n')
            self.Description.exportLiteral(outfile, level, name_='Description')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            self.Type = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'URL':
            URL_ = child_.text
            URL_ = self.gds_validate_string(URL_, node, 'URL')
            self.URL = URL_
        elif nodeName_ == 'Description':
            obj_ = DescriptionType1.factory()
            obj_.build(child_)
            self.Description = obj_
            obj_.original_tagname_ = 'Description'
# end class ReferenceType


class DescriptionType1(localizedString):
    subclass = None
    superclass = localizedString
    def __init__(self, lang='en', valueOf_=None):
        self.original_tagname_ = None
        super(DescriptionType1, self).__init__(lang, valueOf_, )
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if DescriptionType1.subclass:
            return DescriptionType1.subclass(*args_, **kwargs_)
        else:
            return DescriptionType1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(DescriptionType1, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='DescriptionType1', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DescriptionType1')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='DescriptionType1', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='DescriptionType1'):
        super(DescriptionType1, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DescriptionType1')
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='DescriptionType1', fromsubclass_=False, pretty_print=True):
        super(DescriptionType1, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='DescriptionType1'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DescriptionType1, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DescriptionType1, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DescriptionType1, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DescriptionType1


class AcknowledgmentsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Acknowledgment=None):
        self.original_tagname_ = None
        if Acknowledgment is None:
            self.Acknowledgment = []
        else:
            self.Acknowledgment = Acknowledgment
    def factory(*args_, **kwargs_):
        if AcknowledgmentsType.subclass:
            return AcknowledgmentsType.subclass(*args_, **kwargs_)
        else:
            return AcknowledgmentsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Acknowledgment(self): return self.Acknowledgment
    def set_Acknowledgment(self, Acknowledgment): self.Acknowledgment = Acknowledgment
    def add_Acknowledgment(self, value): self.Acknowledgment.append(value)
    def insert_Acknowledgment_at(self, index, value): self.Acknowledgment.insert(index, value)
    def replace_Acknowledgment_at(self, index, value): self.Acknowledgment[index] = value
    def hasContent_(self):
        if (
            self.Acknowledgment
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='AcknowledgmentsType', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AcknowledgmentsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='AcknowledgmentsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='AcknowledgmentsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='AcknowledgmentsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Acknowledgment_ in self.Acknowledgment:
            Acknowledgment_.export(outfile, level, namespace_, name_='Acknowledgment', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='AcknowledgmentsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Acknowledgment=[\n')
        level += 1
        for Acknowledgment_ in self.Acknowledgment:
            showIndent(outfile, level)
            outfile.write('model_.AcknowledgmentType(\n')
            Acknowledgment_.exportLiteral(outfile, level, name_='AcknowledgmentType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Acknowledgment':
            obj_ = AcknowledgmentType.factory()
            obj_.build(child_)
            self.Acknowledgment.append(obj_)
            obj_.original_tagname_ = 'Acknowledgment'
# end class AcknowledgmentsType


class AcknowledgmentType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Name=None, Organization=None, Description=None, URL=None):
        self.original_tagname_ = None
        if Name is None:
            self.Name = []
        else:
            self.Name = Name
        if Organization is None:
            self.Organization = []
        else:
            self.Organization = Organization
        self.Description = Description
        if URL is None:
            self.URL = []
        else:
            self.URL = URL
    def factory(*args_, **kwargs_):
        if AcknowledgmentType.subclass:
            return AcknowledgmentType.subclass(*args_, **kwargs_)
        else:
            return AcknowledgmentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def add_Name(self, value): self.Name.append(value)
    def insert_Name_at(self, index, value): self.Name.insert(index, value)
    def replace_Name_at(self, index, value): self.Name[index] = value
    def get_Organization(self): return self.Organization
    def set_Organization(self, Organization): self.Organization = Organization
    def add_Organization(self, value): self.Organization.append(value)
    def insert_Organization_at(self, index, value): self.Organization.insert(index, value)
    def replace_Organization_at(self, index, value): self.Organization[index] = value
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_URL(self): return self.URL
    def set_URL(self, URL): self.URL = URL
    def add_URL(self, value): self.URL.append(value)
    def insert_URL_at(self, index, value): self.URL.insert(index, value)
    def replace_URL_at(self, index, value): self.URL[index] = value
    def hasContent_(self):
        if (
            self.Name or
            self.Organization or
            self.Description is not None or
            self.URL
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='AcknowledgmentType', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AcknowledgmentType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='AcknowledgmentType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='AcknowledgmentType'):
        pass
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='AcknowledgmentType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Name_ in self.Name:
            Name_.export(outfile, level, namespace_, name_='Name', pretty_print=pretty_print)
        for Organization_ in self.Organization:
            Organization_.export(outfile, level, namespace_, name_='Organization', pretty_print=pretty_print)
        if self.Description is not None:
            self.Description.export(outfile, level, namespace_, name_='Description', pretty_print=pretty_print)
        for URL_ in self.URL:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sURL>%s</%sURL>%s' % (namespace_, self.gds_format_string(quote_xml(URL_).encode(ExternalEncoding), input_name='URL'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='AcknowledgmentType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Name=[\n')
        level += 1
        for Name_ in self.Name:
            showIndent(outfile, level)
            outfile.write('model_.NameType(\n')
            Name_.exportLiteral(outfile, level, name_='NameType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Organization=[\n')
        level += 1
        for Organization_ in self.Organization:
            showIndent(outfile, level)
            outfile.write('model_.OrganizationType(\n')
            Organization_.exportLiteral(outfile, level, name_='OrganizationType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('Description=model_.DescriptionType2(\n')
            self.Description.exportLiteral(outfile, level, name_='Description')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('URL=[\n')
        level += 1
        for URL_ in self.URL:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(URL_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            obj_ = NameType.factory()
            obj_.build(child_)
            self.Name.append(obj_)
            obj_.original_tagname_ = 'Name'
        elif nodeName_ == 'Organization':
            obj_ = OrganizationType.factory()
            obj_.build(child_)
            self.Organization.append(obj_)
            obj_.original_tagname_ = 'Organization'
        elif nodeName_ == 'Description':
            obj_ = DescriptionType2.factory()
            obj_.build(child_)
            self.Description = obj_
            obj_.original_tagname_ = 'Description'
        elif nodeName_ == 'URL':
            URL_ = child_.text
            URL_ = self.gds_validate_string(URL_, node, 'URL')
            self.URL.append(URL_)
# end class AcknowledgmentType


class NameType(localizedString):
    subclass = None
    superclass = localizedString
    def __init__(self, lang='en', valueOf_=None):
        self.original_tagname_ = None
        super(NameType, self).__init__(lang, valueOf_, )
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if NameType.subclass:
            return NameType.subclass(*args_, **kwargs_)
        else:
            return NameType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(NameType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='NameType', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NameType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='NameType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='NameType'):
        super(NameType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='NameType')
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='NameType', fromsubclass_=False, pretty_print=True):
        super(NameType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='NameType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(NameType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(NameType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(NameType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class NameType


class OrganizationType(localizedString):
    subclass = None
    superclass = localizedString
    def __init__(self, lang='en', valueOf_=None):
        self.original_tagname_ = None
        super(OrganizationType, self).__init__(lang, valueOf_, )
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if OrganizationType.subclass:
            return OrganizationType.subclass(*args_, **kwargs_)
        else:
            return OrganizationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(OrganizationType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='OrganizationType', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OrganizationType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='OrganizationType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='OrganizationType'):
        super(OrganizationType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='OrganizationType')
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='OrganizationType', fromsubclass_=False, pretty_print=True):
        super(OrganizationType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='OrganizationType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(OrganizationType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(OrganizationType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(OrganizationType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class OrganizationType


class DescriptionType2(localizedString):
    subclass = None
    superclass = localizedString
    def __init__(self, lang='en', valueOf_=None):
        self.original_tagname_ = None
        super(DescriptionType2, self).__init__(lang, valueOf_, )
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if DescriptionType2.subclass:
            return DescriptionType2.subclass(*args_, **kwargs_)
        else:
            return DescriptionType2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(DescriptionType2, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='DescriptionType2', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DescriptionType2')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='DescriptionType2', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='DescriptionType2'):
        super(DescriptionType2, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DescriptionType2')
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='DescriptionType2', fromsubclass_=False, pretty_print=True):
        super(DescriptionType2, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='DescriptionType2'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DescriptionType2, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DescriptionType2, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DescriptionType2, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DescriptionType2


class TitleType(localizedString):
    subclass = None
    superclass = localizedString
    def __init__(self, lang='en', valueOf_=None):
        self.original_tagname_ = None
        super(TitleType, self).__init__(lang, valueOf_, )
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if TitleType.subclass:
            return TitleType.subclass(*args_, **kwargs_)
        else:
            return TitleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(TitleType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='TitleType', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TitleType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='TitleType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='TitleType'):
        super(TitleType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='TitleType')
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='TitleType', fromsubclass_=False, pretty_print=True):
        super(TitleType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='TitleType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(TitleType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(TitleType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(TitleType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class TitleType


class IDType3(GeneratedsSuper):
    """System Name indicates the name of the vulnerability tracking or
    numbering system that this vulnerability ID comes from."""
    subclass = None
    superclass = None
    def __init__(self, SystemName=None, valueOf_=None):
        self.original_tagname_ = None
        self.SystemName = _cast(None, SystemName)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if IDType3.subclass:
            return IDType3.subclass(*args_, **kwargs_)
        else:
            return IDType3(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SystemName(self): return self.SystemName
    def set_SystemName(self, SystemName): self.SystemName = SystemName
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='IDType3', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IDType3')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='IDType3', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='IDType3'):
        if self.SystemName is not None and 'SystemName' not in already_processed:
            already_processed.add('SystemName')
            outfile.write(' SystemName=%s' % (self.gds_format_string(quote_attrib(self.SystemName).encode(ExternalEncoding), input_name='SystemName'), ))
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='IDType3', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='IDType3'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.SystemName is not None and 'SystemName' not in already_processed:
            already_processed.add('SystemName')
            showIndent(outfile, level)
            outfile.write('SystemName="%s",\n' % (self.SystemName,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('SystemName', node)
        if value is not None and 'SystemName' not in already_processed:
            already_processed.add('SystemName')
            self.SystemName = value
            self.SystemName = ' '.join(self.SystemName.split())
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class IDType3


class NotesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Note=None):
        self.original_tagname_ = None
        if Note is None:
            self.Note = []
        else:
            self.Note = Note
    def factory(*args_, **kwargs_):
        if NotesType.subclass:
            return NotesType.subclass(*args_, **kwargs_)
        else:
            return NotesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Note(self): return self.Note
    def set_Note(self, Note): self.Note = Note
    def add_Note(self, value): self.Note.append(value)
    def insert_Note_at(self, index, value): self.Note.insert(index, value)
    def replace_Note_at(self, index, value): self.Note[index] = value
    def hasContent_(self):
        if (
            self.Note
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='NotesType', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NotesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='NotesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='NotesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='NotesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Note_ in self.Note:
            Note_.export(outfile, level, namespace_, name_='Note', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='NotesType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Note=[\n')
        level += 1
        for Note_ in self.Note:
            showIndent(outfile, level)
            outfile.write('model_.NoteType4(\n')
            Note_.exportLiteral(outfile, level, name_='NoteType4')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Note':
            obj_ = NoteType4.factory()
            obj_.build(child_)
            self.Note.append(obj_)
            obj_.original_tagname_ = 'Note'
# end class NotesType


class NoteType4(localizedString):
    """Title should be a concise description of what is contained in
    Vulnerability Notes.Audience will indicate who is intended to
    read the note.Type of content within this note.Ordinal is a
    locally significant integral counter indexed from 1 used to
    track notes."""
    subclass = None
    superclass = localizedString
    def __init__(self, lang='en', Ordinal=None, Audience=None, Type=None, Title=None, valueOf_=None):
        self.original_tagname_ = None
        super(NoteType4, self).__init__(lang, valueOf_, )
        self.Ordinal = _cast(int, Ordinal)
        self.Audience = _cast(None, Audience)
        self.Type = _cast(None, Type)
        self.Title = _cast(None, Title)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if NoteType4.subclass:
            return NoteType4.subclass(*args_, **kwargs_)
        else:
            return NoteType4(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Ordinal(self): return self.Ordinal
    def set_Ordinal(self, Ordinal): self.Ordinal = Ordinal
    def get_Audience(self): return self.Audience
    def set_Audience(self, Audience): self.Audience = Audience
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_Title(self): return self.Title
    def set_Title(self, Title): self.Title = Title
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(NoteType4, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='NoteType4', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NoteType4')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='NoteType4', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='NoteType4'):
        super(NoteType4, self).exportAttributes(outfile, level, already_processed, namespace_, name_='NoteType4')
        if self.Ordinal is not None and 'Ordinal' not in already_processed:
            already_processed.add('Ordinal')
            outfile.write(' Ordinal="%s"' % self.gds_format_integer(self.Ordinal, input_name='Ordinal'))
        if self.Audience is not None and 'Audience' not in already_processed:
            already_processed.add('Audience')
            outfile.write(' Audience=%s' % (self.gds_format_string(quote_attrib(self.Audience).encode(ExternalEncoding), input_name='Audience'), ))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            outfile.write(' Type=%s' % (quote_attrib(self.Type), ))
        if self.Title is not None and 'Title' not in already_processed:
            already_processed.add('Title')
            outfile.write(' Title=%s' % (self.gds_format_string(quote_attrib(self.Title).encode(ExternalEncoding), input_name='Title'), ))
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='NoteType4', fromsubclass_=False, pretty_print=True):
        super(NoteType4, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='NoteType4'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Ordinal is not None and 'Ordinal' not in already_processed:
            already_processed.add('Ordinal')
            showIndent(outfile, level)
            outfile.write('Ordinal=%d,\n' % (self.Ordinal,))
        if self.Audience is not None and 'Audience' not in already_processed:
            already_processed.add('Audience')
            showIndent(outfile, level)
            outfile.write('Audience="%s",\n' % (self.Audience,))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            showIndent(outfile, level)
            outfile.write('Type=%s,\n' % (self.Type,))
        if self.Title is not None and 'Title' not in already_processed:
            already_processed.add('Title')
            showIndent(outfile, level)
            outfile.write('Title="%s",\n' % (self.Title,))
        super(NoteType4, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(NoteType4, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Ordinal', node)
        if value is not None and 'Ordinal' not in already_processed:
            already_processed.add('Ordinal')
            try:
                self.Ordinal = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.Ordinal <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('Audience', node)
        if value is not None and 'Audience' not in already_processed:
            already_processed.add('Audience')
            self.Audience = value
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            self.Type = value
        value = find_attr_value_('Title', node)
        if value is not None and 'Title' not in already_processed:
            already_processed.add('Title')
            self.Title = value
        super(NoteType4, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class NoteType4


class InvolvementsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Involvement=None):
        self.original_tagname_ = None
        if Involvement is None:
            self.Involvement = []
        else:
            self.Involvement = Involvement
    def factory(*args_, **kwargs_):
        if InvolvementsType.subclass:
            return InvolvementsType.subclass(*args_, **kwargs_)
        else:
            return InvolvementsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Involvement(self): return self.Involvement
    def set_Involvement(self, Involvement): self.Involvement = Involvement
    def add_Involvement(self, value): self.Involvement.append(value)
    def insert_Involvement_at(self, index, value): self.Involvement.insert(index, value)
    def replace_Involvement_at(self, index, value): self.Involvement[index] = value
    def hasContent_(self):
        if (
            self.Involvement
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='InvolvementsType', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InvolvementsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='InvolvementsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='InvolvementsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='InvolvementsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Involvement_ in self.Involvement:
            Involvement_.export(outfile, level, namespace_, name_='Involvement', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='InvolvementsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Involvement=[\n')
        level += 1
        for Involvement_ in self.Involvement:
            showIndent(outfile, level)
            outfile.write('model_.InvolvementType(\n')
            Involvement_.exportLiteral(outfile, level, name_='InvolvementType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Involvement':
            obj_ = InvolvementType.factory()
            obj_.build(child_)
            self.Involvement.append(obj_)
            obj_.original_tagname_ = 'Involvement'
# end class InvolvementsType


class InvolvementType(GeneratedsSuper):
    """Type of party with whom the involvement is taking place.Status of
    the involvement with the specified party."""
    subclass = None
    superclass = None
    def __init__(self, Status=None, Party=None, Description=None):
        self.original_tagname_ = None
        self.Status = _cast(None, Status)
        self.Party = _cast(None, Party)
        self.Description = Description
    def factory(*args_, **kwargs_):
        if InvolvementType.subclass:
            return InvolvementType.subclass(*args_, **kwargs_)
        else:
            return InvolvementType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_Status(self): return self.Status
    def set_Status(self, Status): self.Status = Status
    def get_Party(self): return self.Party
    def set_Party(self, Party): self.Party = Party
    def hasContent_(self):
        if (
            self.Description is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='InvolvementType', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InvolvementType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='InvolvementType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='InvolvementType'):
        if self.Status is not None and 'Status' not in already_processed:
            already_processed.add('Status')
            outfile.write(' Status=%s' % (quote_attrib(self.Status), ))
        if self.Party is not None and 'Party' not in already_processed:
            already_processed.add('Party')
            outfile.write(' Party=%s' % (quote_attrib(self.Party), ))
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='InvolvementType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Description is not None:
            self.Description.export(outfile, level, namespace_, name_='Description', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='InvolvementType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Status is not None and 'Status' not in already_processed:
            already_processed.add('Status')
            showIndent(outfile, level)
            outfile.write('Status=%s,\n' % (self.Status,))
        if self.Party is not None and 'Party' not in already_processed:
            already_processed.add('Party')
            showIndent(outfile, level)
            outfile.write('Party=%s,\n' % (self.Party,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('Description=model_.DescriptionType5(\n')
            self.Description.exportLiteral(outfile, level, name_='Description')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Status', node)
        if value is not None and 'Status' not in already_processed:
            already_processed.add('Status')
            self.Status = value
        value = find_attr_value_('Party', node)
        if value is not None and 'Party' not in already_processed:
            already_processed.add('Party')
            self.Party = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Description':
            obj_ = DescriptionType5.factory()
            obj_.build(child_)
            self.Description = obj_
            obj_.original_tagname_ = 'Description'
# end class InvolvementType


class DescriptionType5(localizedString):
    subclass = None
    superclass = localizedString
    def __init__(self, lang='en', valueOf_=None):
        self.original_tagname_ = None
        super(DescriptionType5, self).__init__(lang, valueOf_, )
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if DescriptionType5.subclass:
            return DescriptionType5.subclass(*args_, **kwargs_)
        else:
            return DescriptionType5(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(DescriptionType5, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='DescriptionType5', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DescriptionType5')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='DescriptionType5', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='DescriptionType5'):
        super(DescriptionType5, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DescriptionType5')
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='DescriptionType5', fromsubclass_=False, pretty_print=True):
        super(DescriptionType5, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='DescriptionType5'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DescriptionType5, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DescriptionType5, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DescriptionType5, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DescriptionType5


class CWEType(localizedString):
    """The MITRE-assigned CWE identifier."""
    subclass = None
    superclass = localizedString
    def __init__(self, lang='en', ID=None, valueOf_=None):
        self.original_tagname_ = None
        super(CWEType, self).__init__(lang, valueOf_, )
        self.ID = _cast(None, ID)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CWEType.subclass:
            return CWEType.subclass(*args_, **kwargs_)
        else:
            return CWEType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(CWEType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='CWEType', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CWEType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='CWEType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='CWEType'):
        super(CWEType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CWEType')
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (quote_attrib(self.ID), ))
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='CWEType', fromsubclass_=False, pretty_print=True):
        super(CWEType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='CWEType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            showIndent(outfile, level)
            outfile.write('ID=%s,\n' % (self.ID,))
        super(CWEType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(CWEType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        super(CWEType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CWEType


class ProductStatusesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Status=None):
        self.original_tagname_ = None
        if Status is None:
            self.Status = []
        else:
            self.Status = Status
    def factory(*args_, **kwargs_):
        if ProductStatusesType.subclass:
            return ProductStatusesType.subclass(*args_, **kwargs_)
        else:
            return ProductStatusesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Status(self): return self.Status
    def set_Status(self, Status): self.Status = Status
    def add_Status(self, value): self.Status.append(value)
    def insert_Status_at(self, index, value): self.Status.insert(index, value)
    def replace_Status_at(self, index, value): self.Status[index] = value
    def hasContent_(self):
        if (
            self.Status
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='ProductStatusesType', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProductStatusesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='ProductStatusesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='ProductStatusesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='ProductStatusesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Status_ in self.Status:
            Status_.export(outfile, level, namespace_, name_='Status', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ProductStatusesType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Status=[\n')
        level += 1
        for Status_ in self.Status:
            showIndent(outfile, level)
            outfile.write('model_.StatusType(\n')
            Status_.exportLiteral(outfile, level, name_='StatusType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Status':
            obj_ = StatusType.factory()
            obj_.build(child_)
            self.Status.append(obj_)
            obj_.original_tagname_ = 'Status'
# end class ProductStatusesType


class StatusType(GeneratedsSuper):
    """Affected status for the product or products defined in this
    container."""
    subclass = None
    superclass = None
    def __init__(self, Type=None, ProductID=None):
        self.original_tagname_ = None
        self.Type = _cast(None, Type)
        if ProductID is None:
            self.ProductID = []
        else:
            self.ProductID = ProductID
    def factory(*args_, **kwargs_):
        if StatusType.subclass:
            return StatusType.subclass(*args_, **kwargs_)
        else:
            return StatusType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ProductID(self): return self.ProductID
    def set_ProductID(self, ProductID): self.ProductID = ProductID
    def add_ProductID(self, value): self.ProductID.append(value)
    def insert_ProductID_at(self, index, value): self.ProductID.insert(index, value)
    def replace_ProductID_at(self, index, value): self.ProductID[index] = value
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def hasContent_(self):
        if (
            self.ProductID
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='StatusType', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1" xmlns:vuln="http://www.icasi.org/CVRF/schema/vuln/1.1" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StatusType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='StatusType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='StatusType'):
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            outfile.write(' Type=%s' % (quote_attrib(self.Type), ))
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='StatusType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ProductID_ in self.ProductID:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sProductID>%s</%sProductID>%s' % (namespace_, self.gds_format_string(quote_xml(ProductID_).encode(ExternalEncoding), input_name='ProductID'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='StatusType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            showIndent(outfile, level)
            outfile.write('Type=%s,\n' % (self.Type,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('ProductID=[\n')
        level += 1
        for ProductID_ in self.ProductID:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(ProductID_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            self.Type = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ProductID':
            ProductID_ = child_.text
            ProductID_ = re_.sub(String_cleanup_pat_, " ", ProductID_).strip()
            ProductID_ = self.gds_validate_string(ProductID_, node, 'ProductID')
            self.ProductID.append(ProductID_)
# end class StatusType


class ThreatsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Threat=None):
        self.original_tagname_ = None
        if Threat is None:
            self.Threat = []
        else:
            self.Threat = Threat
    def factory(*args_, **kwargs_):
        if ThreatsType.subclass:
            return ThreatsType.subclass(*args_, **kwargs_)
        else:
            return ThreatsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Threat(self): return self.Threat
    def set_Threat(self, Threat): self.Threat = Threat
    def add_Threat(self, value): self.Threat.append(value)
    def insert_Threat_at(self, index, value): self.Threat.insert(index, value)
    def replace_Threat_at(self, index, value): self.Threat[index] = value
    def hasContent_(self):
        if (
            self.Threat
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='ThreatsType', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ThreatsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='ThreatsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='ThreatsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='ThreatsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Threat_ in self.Threat:
            Threat_.export(outfile, level, namespace_, name_='Threat', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ThreatsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Threat=[\n')
        level += 1
        for Threat_ in self.Threat:
            showIndent(outfile, level)
            outfile.write('model_.ThreatType(\n')
            Threat_.exportLiteral(outfile, level, name_='ThreatType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Threat':
            obj_ = ThreatType.factory()
            obj_.build(child_)
            self.Threat.append(obj_)
            obj_.original_tagname_ = 'Threat'
# end class ThreatsType


class ThreatType(GeneratedsSuper):
    """The type of the Threat.The date this Threat item was last updated;
    if omitted it is deemed to be unknown, irrelevant, or
    unimportant."""
    subclass = None
    superclass = None
    def __init__(self, Date=None, Type=None, Description=None, ProductID=None, GroupID=None):
        self.original_tagname_ = None
        if isinstance(Date, basestring):
            initvalue_ = datetime_.datetime.strptime(Date, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = Date
        self.Date = initvalue_
        self.Type = _cast(None, Type)
        self.Description = Description
        if ProductID is None:
            self.ProductID = []
        else:
            self.ProductID = ProductID
        if GroupID is None:
            self.GroupID = []
        else:
            self.GroupID = GroupID
    def factory(*args_, **kwargs_):
        if ThreatType.subclass:
            return ThreatType.subclass(*args_, **kwargs_)
        else:
            return ThreatType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_ProductID(self): return self.ProductID
    def set_ProductID(self, ProductID): self.ProductID = ProductID
    def add_ProductID(self, value): self.ProductID.append(value)
    def insert_ProductID_at(self, index, value): self.ProductID.insert(index, value)
    def replace_ProductID_at(self, index, value): self.ProductID[index] = value
    def get_GroupID(self): return self.GroupID
    def set_GroupID(self, GroupID): self.GroupID = GroupID
    def add_GroupID(self, value): self.GroupID.append(value)
    def insert_GroupID_at(self, index, value): self.GroupID.insert(index, value)
    def replace_GroupID_at(self, index, value): self.GroupID[index] = value
    def get_Date(self): return self.Date
    def set_Date(self, Date): self.Date = Date
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def hasContent_(self):
        if (
            self.Description is not None or
            self.ProductID or
            self.GroupID
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='ThreatType', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1" xmlns:vuln="http://www.icasi.org/CVRF/schema/vuln/1.1" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ThreatType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='ThreatType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='ThreatType'):
        if self.Date is not None and 'Date' not in already_processed:
            already_processed.add('Date')
            outfile.write(' Date="%s"' % self.gds_format_datetime(self.Date, input_name='Date'))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            outfile.write(' Type=%s' % (quote_attrib(self.Type), ))
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='ThreatType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Description is not None:
            self.Description.export(outfile, level, namespace_, name_='Description', pretty_print=pretty_print)
        for ProductID_ in self.ProductID:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sProductID>%s</%sProductID>%s' % (namespace_, self.gds_format_string(quote_xml(ProductID_).encode(ExternalEncoding), input_name='ProductID'), namespace_, eol_))
        for GroupID_ in self.GroupID:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGroupID>%s</%sGroupID>%s' % (namespace_, self.gds_format_string(quote_xml(GroupID_).encode(ExternalEncoding), input_name='GroupID'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='ThreatType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Date is not None and 'Date' not in already_processed:
            already_processed.add('Date')
            showIndent(outfile, level)
            outfile.write('Date=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.Date, input_name='Date'))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            showIndent(outfile, level)
            outfile.write('Type=%s,\n' % (self.Type,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('Description=model_.DescriptionType6(\n')
            self.Description.exportLiteral(outfile, level, name_='Description')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('ProductID=[\n')
        level += 1
        for ProductID_ in self.ProductID:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(ProductID_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('GroupID=[\n')
        level += 1
        for GroupID_ in self.GroupID:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(GroupID_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Date', node)
        if value is not None and 'Date' not in already_processed:
            already_processed.add('Date')
            try:
                self.Date = self.gds_parse_datetime(value)
            except ValueError, exp:
                raise ValueError('Bad date-time attribute (Date): %s' % exp)
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            self.Type = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Description':
            obj_ = DescriptionType6.factory()
            obj_.build(child_)
            self.Description = obj_
            obj_.original_tagname_ = 'Description'
        elif nodeName_ == 'ProductID':
            ProductID_ = child_.text
            ProductID_ = re_.sub(String_cleanup_pat_, " ", ProductID_).strip()
            ProductID_ = self.gds_validate_string(ProductID_, node, 'ProductID')
            self.ProductID.append(ProductID_)
        elif nodeName_ == 'GroupID':
            GroupID_ = child_.text
            GroupID_ = re_.sub(String_cleanup_pat_, " ", GroupID_).strip()
            GroupID_ = self.gds_validate_string(GroupID_, node, 'GroupID')
            self.GroupID.append(GroupID_)
# end class ThreatType


class DescriptionType6(localizedString):
    subclass = None
    superclass = localizedString
    def __init__(self, lang='en', valueOf_=None):
        self.original_tagname_ = None
        super(DescriptionType6, self).__init__(lang, valueOf_, )
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if DescriptionType6.subclass:
            return DescriptionType6.subclass(*args_, **kwargs_)
        else:
            return DescriptionType6(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(DescriptionType6, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='DescriptionType6', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DescriptionType6')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='DescriptionType6', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='DescriptionType6'):
        super(DescriptionType6, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DescriptionType6')
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='DescriptionType6', fromsubclass_=False, pretty_print=True):
        super(DescriptionType6, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='DescriptionType6'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DescriptionType6, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DescriptionType6, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DescriptionType6, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DescriptionType6


class CVSSScoreSetsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ScoreSet=None):
        self.original_tagname_ = None
        if ScoreSet is None:
            self.ScoreSet = []
        else:
            self.ScoreSet = ScoreSet
    def factory(*args_, **kwargs_):
        if CVSSScoreSetsType.subclass:
            return CVSSScoreSetsType.subclass(*args_, **kwargs_)
        else:
            return CVSSScoreSetsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ScoreSet(self): return self.ScoreSet
    def set_ScoreSet(self, ScoreSet): self.ScoreSet = ScoreSet
    def add_ScoreSet(self, value): self.ScoreSet.append(value)
    def insert_ScoreSet_at(self, index, value): self.ScoreSet.insert(index, value)
    def replace_ScoreSet_at(self, index, value): self.ScoreSet[index] = value
    def hasContent_(self):
        if (
            self.ScoreSet
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='CVSSScoreSetsType', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CVSSScoreSetsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='CVSSScoreSetsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='CVSSScoreSetsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='CVSSScoreSetsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ScoreSet_ in self.ScoreSet:
            ScoreSet_.export(outfile, level, namespace_, name_='ScoreSet', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='CVSSScoreSetsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('ScoreSet=[\n')
        level += 1
        for ScoreSet_ in self.ScoreSet:
            showIndent(outfile, level)
            outfile.write('model_.ScoreSetType(\n')
            ScoreSet_.exportLiteral(outfile, level, name_='ScoreSetType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ScoreSet':
            obj_ = ScoreSetType.factory()
            obj_.build(child_)
            self.ScoreSet.append(obj_)
            obj_.original_tagname_ = 'ScoreSet'
# end class CVSSScoreSetsType


class ScoreSetType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, BaseScore=None, TemporalScore=None, EnvironmentalScore=None, Vector=None, ProductID=None):
        self.original_tagname_ = None
        self.BaseScore = BaseScore
        self.validate_zeroToTenDecimalType(self.BaseScore)
        self.TemporalScore = TemporalScore
        self.validate_zeroToTenDecimalType(self.TemporalScore)
        self.EnvironmentalScore = EnvironmentalScore
        self.validate_zeroToTenDecimalType(self.EnvironmentalScore)
        self.Vector = Vector
        self.validate_cvssVector(self.Vector)
        if ProductID is None:
            self.ProductID = []
        else:
            self.ProductID = ProductID
    def factory(*args_, **kwargs_):
        if ScoreSetType.subclass:
            return ScoreSetType.subclass(*args_, **kwargs_)
        else:
            return ScoreSetType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_BaseScore(self): return self.BaseScore
    def set_BaseScore(self, BaseScore): self.BaseScore = BaseScore
    def get_TemporalScore(self): return self.TemporalScore
    def set_TemporalScore(self, TemporalScore): self.TemporalScore = TemporalScore
    def get_EnvironmentalScore(self): return self.EnvironmentalScore
    def set_EnvironmentalScore(self, EnvironmentalScore): self.EnvironmentalScore = EnvironmentalScore
    def get_Vector(self): return self.Vector
    def set_Vector(self, Vector): self.Vector = Vector
    def get_ProductID(self): return self.ProductID
    def set_ProductID(self, ProductID): self.ProductID = ProductID
    def add_ProductID(self, value): self.ProductID.append(value)
    def insert_ProductID_at(self, index, value): self.ProductID.insert(index, value)
    def replace_ProductID_at(self, index, value): self.ProductID[index] = value
    def validate_zeroToTenDecimalType(self, value):
        # Validate type zeroToTenDecimalType, a restriction on xsd:decimal.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on zeroToTenDecimalType' % {"value" : value} )
            if value > 10:
                warnings_.warn('Value "%(value)s" does not match xsd maxInclusive restriction on zeroToTenDecimalType' % {"value" : value} )
    def validate_cvssVector(self, value):
        # Validate type cvssVector, a restriction on xs:token.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 76:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on cvssVector' % {"value" : value} )
    def hasContent_(self):
        if (
            self.BaseScore is not None or
            self.TemporalScore is not None or
            self.EnvironmentalScore is not None or
            self.Vector is not None or
            self.ProductID
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='ScoreSetType', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1" xmlns:vuln="http://www.icasi.org/CVRF/schema/vuln/1.1" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ScoreSetType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='ScoreSetType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='ScoreSetType'):
        pass
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='ScoreSetType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.BaseScore is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBaseScore>%s</%sBaseScore>%s' % (namespace_, self.gds_format_float(self.BaseScore, input_name='BaseScore'), namespace_, eol_))
        if self.TemporalScore is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTemporalScore>%s</%sTemporalScore>%s' % (namespace_, self.gds_format_float(self.TemporalScore, input_name='TemporalScore'), namespace_, eol_))
        if self.EnvironmentalScore is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEnvironmentalScore>%s</%sEnvironmentalScore>%s' % (namespace_, self.gds_format_float(self.EnvironmentalScore, input_name='EnvironmentalScore'), namespace_, eol_))
        if self.Vector is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVector>%s</%sVector>%s' % (namespace_, self.gds_format_string(quote_xml(self.Vector).encode(ExternalEncoding), input_name='Vector'), namespace_, eol_))
        for ProductID_ in self.ProductID:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sProductID>%s</%sProductID>%s' % (namespace_, self.gds_format_string(quote_xml(ProductID_).encode(ExternalEncoding), input_name='ProductID'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='ScoreSetType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.BaseScore is not None:
            showIndent(outfile, level)
            outfile.write('BaseScore=%f,\n' % self.BaseScore)
        if self.TemporalScore is not None:
            showIndent(outfile, level)
            outfile.write('TemporalScore=%f,\n' % self.TemporalScore)
        if self.EnvironmentalScore is not None:
            showIndent(outfile, level)
            outfile.write('EnvironmentalScore=%f,\n' % self.EnvironmentalScore)
        if self.Vector is not None:
            showIndent(outfile, level)
            outfile.write('Vector=%s,\n' % quote_python(self.Vector).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('ProductID=[\n')
        level += 1
        for ProductID_ in self.ProductID:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(ProductID_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'BaseScore':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'BaseScore')
            self.BaseScore = fval_
            self.validate_zeroToTenDecimalType(self.BaseScore)    # validate type zeroToTenDecimalType
        elif nodeName_ == 'TemporalScore':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'TemporalScore')
            self.TemporalScore = fval_
            self.validate_zeroToTenDecimalType(self.TemporalScore)    # validate type zeroToTenDecimalType
        elif nodeName_ == 'EnvironmentalScore':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'EnvironmentalScore')
            self.EnvironmentalScore = fval_
            self.validate_zeroToTenDecimalType(self.EnvironmentalScore)    # validate type zeroToTenDecimalType
        elif nodeName_ == 'Vector':
            Vector_ = child_.text
            Vector_ = re_.sub(String_cleanup_pat_, " ", Vector_).strip()
            Vector_ = self.gds_validate_string(Vector_, node, 'Vector')
            self.Vector = Vector_
            self.validate_cvssVector(self.Vector)    # validate type cvssVector
        elif nodeName_ == 'ProductID':
            ProductID_ = child_.text
            ProductID_ = re_.sub(String_cleanup_pat_, " ", ProductID_).strip()
            ProductID_ = self.gds_validate_string(ProductID_, node, 'ProductID')
            self.ProductID.append(ProductID_)
# end class ScoreSetType


class RemediationsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Remediation=None):
        self.original_tagname_ = None
        if Remediation is None:
            self.Remediation = []
        else:
            self.Remediation = Remediation
    def factory(*args_, **kwargs_):
        if RemediationsType.subclass:
            return RemediationsType.subclass(*args_, **kwargs_)
        else:
            return RemediationsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Remediation(self): return self.Remediation
    def set_Remediation(self, Remediation): self.Remediation = Remediation
    def add_Remediation(self, value): self.Remediation.append(value)
    def insert_Remediation_at(self, index, value): self.Remediation.insert(index, value)
    def replace_Remediation_at(self, index, value): self.Remediation[index] = value
    def hasContent_(self):
        if (
            self.Remediation
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='RemediationsType', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RemediationsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='RemediationsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='RemediationsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='RemediationsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Remediation_ in self.Remediation:
            Remediation_.export(outfile, level, namespace_, name_='Remediation', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='RemediationsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Remediation=[\n')
        level += 1
        for Remediation_ in self.Remediation:
            showIndent(outfile, level)
            outfile.write('model_.RemediationType(\n')
            Remediation_.exportLiteral(outfile, level, name_='RemediationType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Remediation':
            obj_ = RemediationType.factory()
            obj_.build(child_)
            self.Remediation.append(obj_)
            obj_.original_tagname_ = 'Remediation'
# end class RemediationsType


class RemediationType(GeneratedsSuper):
    """Specific type of remedy.The date Remedy was last updated, if omitted
    it is deemed to be unknown, unimportant, or irrelevant."""
    subclass = None
    superclass = None
    def __init__(self, Date=None, Type=None, Description=None, Entitlement=None, URL=None, ProductID=None, GroupID=None):
        self.original_tagname_ = None
        if isinstance(Date, basestring):
            initvalue_ = datetime_.datetime.strptime(Date, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = Date
        self.Date = initvalue_
        self.Type = _cast(None, Type)
        self.Description = Description
        if Entitlement is None:
            self.Entitlement = []
        else:
            self.Entitlement = Entitlement
        self.URL = URL
        if ProductID is None:
            self.ProductID = []
        else:
            self.ProductID = ProductID
        if GroupID is None:
            self.GroupID = []
        else:
            self.GroupID = GroupID
    def factory(*args_, **kwargs_):
        if RemediationType.subclass:
            return RemediationType.subclass(*args_, **kwargs_)
        else:
            return RemediationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_Entitlement(self): return self.Entitlement
    def set_Entitlement(self, Entitlement): self.Entitlement = Entitlement
    def add_Entitlement(self, value): self.Entitlement.append(value)
    def insert_Entitlement_at(self, index, value): self.Entitlement.insert(index, value)
    def replace_Entitlement_at(self, index, value): self.Entitlement[index] = value
    def get_URL(self): return self.URL
    def set_URL(self, URL): self.URL = URL
    def get_ProductID(self): return self.ProductID
    def set_ProductID(self, ProductID): self.ProductID = ProductID
    def add_ProductID(self, value): self.ProductID.append(value)
    def insert_ProductID_at(self, index, value): self.ProductID.insert(index, value)
    def replace_ProductID_at(self, index, value): self.ProductID[index] = value
    def get_GroupID(self): return self.GroupID
    def set_GroupID(self, GroupID): self.GroupID = GroupID
    def add_GroupID(self, value): self.GroupID.append(value)
    def insert_GroupID_at(self, index, value): self.GroupID.insert(index, value)
    def replace_GroupID_at(self, index, value): self.GroupID[index] = value
    def get_Date(self): return self.Date
    def set_Date(self, Date): self.Date = Date
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def hasContent_(self):
        if (
            self.Description is not None or
            self.Entitlement or
            self.URL is not None or
            self.ProductID or
            self.GroupID
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='RemediationType', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1" xmlns:vuln="http://www.icasi.org/CVRF/schema/vuln/1.1" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RemediationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='RemediationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='RemediationType'):
        if self.Date is not None and 'Date' not in already_processed:
            already_processed.add('Date')
            outfile.write(' Date="%s"' % self.gds_format_datetime(self.Date, input_name='Date'))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            outfile.write(' Type=%s' % (quote_attrib(self.Type), ))
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='RemediationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Description is not None:
            self.Description.export(outfile, level, namespace_, name_='Description', pretty_print=pretty_print)
        for Entitlement_ in self.Entitlement:
            Entitlement_.export(outfile, level, namespace_, name_='Entitlement', pretty_print=pretty_print)
        if self.URL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sURL>%s</%sURL>%s' % (namespace_, self.gds_format_string(quote_xml(self.URL).encode(ExternalEncoding), input_name='URL'), namespace_, eol_))
        for ProductID_ in self.ProductID:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sProductID>%s</%sProductID>%s' % (namespace_, self.gds_format_string(quote_xml(ProductID_).encode(ExternalEncoding), input_name='ProductID'), namespace_, eol_))
        for GroupID_ in self.GroupID:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGroupID>%s</%sGroupID>%s' % (namespace_, self.gds_format_string(quote_xml(GroupID_).encode(ExternalEncoding), input_name='GroupID'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='RemediationType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Date is not None and 'Date' not in already_processed:
            already_processed.add('Date')
            showIndent(outfile, level)
            outfile.write('Date=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.Date, input_name='Date'))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            showIndent(outfile, level)
            outfile.write('Type=%s,\n' % (self.Type,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('Description=model_.DescriptionType7(\n')
            self.Description.exportLiteral(outfile, level, name_='Description')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Entitlement=[\n')
        level += 1
        for Entitlement_ in self.Entitlement:
            showIndent(outfile, level)
            outfile.write('model_.EntitlementType(\n')
            Entitlement_.exportLiteral(outfile, level, name_='EntitlementType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.URL is not None:
            showIndent(outfile, level)
            outfile.write('URL=%s,\n' % quote_python(self.URL).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('ProductID=[\n')
        level += 1
        for ProductID_ in self.ProductID:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(ProductID_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('GroupID=[\n')
        level += 1
        for GroupID_ in self.GroupID:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(GroupID_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Date', node)
        if value is not None and 'Date' not in already_processed:
            already_processed.add('Date')
            try:
                self.Date = self.gds_parse_datetime(value)
            except ValueError, exp:
                raise ValueError('Bad date-time attribute (Date): %s' % exp)
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            self.Type = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Description':
            obj_ = DescriptionType7.factory()
            obj_.build(child_)
            self.Description = obj_
            obj_.original_tagname_ = 'Description'
        elif nodeName_ == 'Entitlement':
            obj_ = EntitlementType.factory()
            obj_.build(child_)
            self.Entitlement.append(obj_)
            obj_.original_tagname_ = 'Entitlement'
        elif nodeName_ == 'URL':
            URL_ = child_.text
            URL_ = self.gds_validate_string(URL_, node, 'URL')
            self.URL = URL_
        elif nodeName_ == 'ProductID':
            ProductID_ = child_.text
            ProductID_ = re_.sub(String_cleanup_pat_, " ", ProductID_).strip()
            ProductID_ = self.gds_validate_string(ProductID_, node, 'ProductID')
            self.ProductID.append(ProductID_)
        elif nodeName_ == 'GroupID':
            GroupID_ = child_.text
            GroupID_ = re_.sub(String_cleanup_pat_, " ", GroupID_).strip()
            GroupID_ = self.gds_validate_string(GroupID_, node, 'GroupID')
            self.GroupID.append(GroupID_)
# end class RemediationType


class DescriptionType7(localizedString):
    subclass = None
    superclass = localizedString
    def __init__(self, lang='en', valueOf_=None):
        self.original_tagname_ = None
        super(DescriptionType7, self).__init__(lang, valueOf_, )
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if DescriptionType7.subclass:
            return DescriptionType7.subclass(*args_, **kwargs_)
        else:
            return DescriptionType7(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(DescriptionType7, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='DescriptionType7', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DescriptionType7')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='DescriptionType7', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='DescriptionType7'):
        super(DescriptionType7, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DescriptionType7')
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='DescriptionType7', fromsubclass_=False, pretty_print=True):
        super(DescriptionType7, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='DescriptionType7'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DescriptionType7, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DescriptionType7, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DescriptionType7, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DescriptionType7


class EntitlementType(localizedString):
    subclass = None
    superclass = localizedString
    def __init__(self, lang='en', valueOf_=None):
        self.original_tagname_ = None
        super(EntitlementType, self).__init__(lang, valueOf_, )
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if EntitlementType.subclass:
            return EntitlementType.subclass(*args_, **kwargs_)
        else:
            return EntitlementType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(EntitlementType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='EntitlementType', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EntitlementType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='EntitlementType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='EntitlementType'):
        super(EntitlementType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='EntitlementType')
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='EntitlementType', fromsubclass_=False, pretty_print=True):
        super(EntitlementType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='EntitlementType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(EntitlementType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(EntitlementType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(EntitlementType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EntitlementType


class ReferencesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Reference=None):
        self.original_tagname_ = None
        if Reference is None:
            self.Reference = []
        else:
            self.Reference = Reference
    def factory(*args_, **kwargs_):
        if ReferencesType.subclass:
            return ReferencesType.subclass(*args_, **kwargs_)
        else:
            return ReferencesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Reference(self): return self.Reference
    def set_Reference(self, Reference): self.Reference = Reference
    def add_Reference(self, value): self.Reference.append(value)
    def insert_Reference_at(self, index, value): self.Reference.insert(index, value)
    def replace_Reference_at(self, index, value): self.Reference[index] = value
    def hasContent_(self):
        if (
            self.Reference
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='ReferencesType', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReferencesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='ReferencesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='ReferencesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='ReferencesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Reference_ in self.Reference:
            Reference_.export(outfile, level, namespace_, name_='Reference', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ReferencesType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Reference=[\n')
        level += 1
        for Reference_ in self.Reference:
            showIndent(outfile, level)
            outfile.write('model_.ReferenceType8(\n')
            Reference_.exportLiteral(outfile, level, name_='ReferenceType8')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Reference':
            obj_ = ReferenceType8.factory()
            obj_.build(child_)
            self.Reference.append(obj_)
            obj_.original_tagname_ = 'Reference'
# end class ReferencesType


class ReferenceType8(GeneratedsSuper):
    """Enumerated type value of reference relative to this document."""
    subclass = None
    superclass = None
    def __init__(self, Type='External', URL=None, Description=None):
        self.original_tagname_ = None
        self.Type = _cast(None, Type)
        self.URL = URL
        self.Description = Description
    def factory(*args_, **kwargs_):
        if ReferenceType8.subclass:
            return ReferenceType8.subclass(*args_, **kwargs_)
        else:
            return ReferenceType8(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_URL(self): return self.URL
    def set_URL(self, URL): self.URL = URL
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def hasContent_(self):
        if (
            self.URL is not None or
            self.Description is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='ReferenceType8', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReferenceType8')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='ReferenceType8', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='ReferenceType8'):
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            outfile.write(' Type=%s' % (quote_attrib(self.Type), ))
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='ReferenceType8', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.URL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sURL>%s</%sURL>%s' % (namespace_, self.gds_format_string(quote_xml(self.URL).encode(ExternalEncoding), input_name='URL'), namespace_, eol_))
        if self.Description is not None:
            self.Description.export(outfile, level, namespace_, name_='Description', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ReferenceType8'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            showIndent(outfile, level)
            outfile.write('Type=%s,\n' % (self.Type,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.URL is not None:
            showIndent(outfile, level)
            outfile.write('URL=%s,\n' % quote_python(self.URL).encode(ExternalEncoding))
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('Description=model_.DescriptionType9(\n')
            self.Description.exportLiteral(outfile, level, name_='Description')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            self.Type = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'URL':
            URL_ = child_.text
            URL_ = self.gds_validate_string(URL_, node, 'URL')
            self.URL = URL_
        elif nodeName_ == 'Description':
            obj_ = DescriptionType9.factory()
            obj_.build(child_)
            self.Description = obj_
            obj_.original_tagname_ = 'Description'
# end class ReferenceType8


class DescriptionType9(localizedString):
    subclass = None
    superclass = localizedString
    def __init__(self, lang='en', valueOf_=None):
        self.original_tagname_ = None
        super(DescriptionType9, self).__init__(lang, valueOf_, )
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if DescriptionType9.subclass:
            return DescriptionType9.subclass(*args_, **kwargs_)
        else:
            return DescriptionType9(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(DescriptionType9, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='DescriptionType9', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DescriptionType9')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='DescriptionType9', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='DescriptionType9'):
        super(DescriptionType9, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DescriptionType9')
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='DescriptionType9', fromsubclass_=False, pretty_print=True):
        super(DescriptionType9, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='DescriptionType9'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DescriptionType9, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DescriptionType9, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DescriptionType9, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DescriptionType9


class AcknowledgmentsType10(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Acknowledgment=None):
        self.original_tagname_ = None
        if Acknowledgment is None:
            self.Acknowledgment = []
        else:
            self.Acknowledgment = Acknowledgment
    def factory(*args_, **kwargs_):
        if AcknowledgmentsType10.subclass:
            return AcknowledgmentsType10.subclass(*args_, **kwargs_)
        else:
            return AcknowledgmentsType10(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Acknowledgment(self): return self.Acknowledgment
    def set_Acknowledgment(self, Acknowledgment): self.Acknowledgment = Acknowledgment
    def add_Acknowledgment(self, value): self.Acknowledgment.append(value)
    def insert_Acknowledgment_at(self, index, value): self.Acknowledgment.insert(index, value)
    def replace_Acknowledgment_at(self, index, value): self.Acknowledgment[index] = value
    def hasContent_(self):
        if (
            self.Acknowledgment
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='AcknowledgmentsType10', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AcknowledgmentsType10')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='AcknowledgmentsType10', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='AcknowledgmentsType10'):
        pass
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='AcknowledgmentsType10', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Acknowledgment_ in self.Acknowledgment:
            Acknowledgment_.export(outfile, level, namespace_, name_='Acknowledgment', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='AcknowledgmentsType10'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Acknowledgment=[\n')
        level += 1
        for Acknowledgment_ in self.Acknowledgment:
            showIndent(outfile, level)
            outfile.write('model_.AcknowledgmentType11(\n')
            Acknowledgment_.exportLiteral(outfile, level, name_='AcknowledgmentType11')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Acknowledgment':
            obj_ = AcknowledgmentType11.factory()
            obj_.build(child_)
            self.Acknowledgment.append(obj_)
            obj_.original_tagname_ = 'Acknowledgment'
# end class AcknowledgmentsType10


class AcknowledgmentType11(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Name=None, Organization=None, Description=None, URL=None):
        self.original_tagname_ = None
        if Name is None:
            self.Name = []
        else:
            self.Name = Name
        if Organization is None:
            self.Organization = []
        else:
            self.Organization = Organization
        self.Description = Description
        if URL is None:
            self.URL = []
        else:
            self.URL = URL
    def factory(*args_, **kwargs_):
        if AcknowledgmentType11.subclass:
            return AcknowledgmentType11.subclass(*args_, **kwargs_)
        else:
            return AcknowledgmentType11(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def add_Name(self, value): self.Name.append(value)
    def insert_Name_at(self, index, value): self.Name.insert(index, value)
    def replace_Name_at(self, index, value): self.Name[index] = value
    def get_Organization(self): return self.Organization
    def set_Organization(self, Organization): self.Organization = Organization
    def add_Organization(self, value): self.Organization.append(value)
    def insert_Organization_at(self, index, value): self.Organization.insert(index, value)
    def replace_Organization_at(self, index, value): self.Organization[index] = value
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_URL(self): return self.URL
    def set_URL(self, URL): self.URL = URL
    def add_URL(self, value): self.URL.append(value)
    def insert_URL_at(self, index, value): self.URL.insert(index, value)
    def replace_URL_at(self, index, value): self.URL[index] = value
    def hasContent_(self):
        if (
            self.Name or
            self.Organization or
            self.Description is not None or
            self.URL
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='AcknowledgmentType11', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AcknowledgmentType11')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='AcknowledgmentType11', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='AcknowledgmentType11'):
        pass
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='AcknowledgmentType11', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Name_ in self.Name:
            Name_.export(outfile, level, namespace_, name_='Name', pretty_print=pretty_print)
        for Organization_ in self.Organization:
            Organization_.export(outfile, level, namespace_, name_='Organization', pretty_print=pretty_print)
        if self.Description is not None:
            self.Description.export(outfile, level, namespace_, name_='Description', pretty_print=pretty_print)
        for URL_ in self.URL:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sURL>%s</%sURL>%s' % (namespace_, self.gds_format_string(quote_xml(URL_).encode(ExternalEncoding), input_name='URL'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='AcknowledgmentType11'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Name=[\n')
        level += 1
        for Name_ in self.Name:
            showIndent(outfile, level)
            outfile.write('model_.NameType12(\n')
            Name_.exportLiteral(outfile, level, name_='NameType12')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Organization=[\n')
        level += 1
        for Organization_ in self.Organization:
            showIndent(outfile, level)
            outfile.write('model_.OrganizationType13(\n')
            Organization_.exportLiteral(outfile, level, name_='OrganizationType13')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('Description=model_.DescriptionType14(\n')
            self.Description.exportLiteral(outfile, level, name_='Description')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('URL=[\n')
        level += 1
        for URL_ in self.URL:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(URL_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            obj_ = NameType12.factory()
            obj_.build(child_)
            self.Name.append(obj_)
            obj_.original_tagname_ = 'Name'
        elif nodeName_ == 'Organization':
            obj_ = OrganizationType13.factory()
            obj_.build(child_)
            self.Organization.append(obj_)
            obj_.original_tagname_ = 'Organization'
        elif nodeName_ == 'Description':
            obj_ = DescriptionType14.factory()
            obj_.build(child_)
            self.Description = obj_
            obj_.original_tagname_ = 'Description'
        elif nodeName_ == 'URL':
            URL_ = child_.text
            URL_ = self.gds_validate_string(URL_, node, 'URL')
            self.URL.append(URL_)
# end class AcknowledgmentType11


class NameType12(localizedString):
    subclass = None
    superclass = localizedString
    def __init__(self, lang='en', valueOf_=None):
        self.original_tagname_ = None
        super(NameType12, self).__init__(lang, valueOf_, )
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if NameType12.subclass:
            return NameType12.subclass(*args_, **kwargs_)
        else:
            return NameType12(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(NameType12, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='NameType12', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NameType12')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='NameType12', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='NameType12'):
        super(NameType12, self).exportAttributes(outfile, level, already_processed, namespace_, name_='NameType12')
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='NameType12', fromsubclass_=False, pretty_print=True):
        super(NameType12, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='NameType12'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(NameType12, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(NameType12, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(NameType12, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class NameType12


class OrganizationType13(localizedString):
    subclass = None
    superclass = localizedString
    def __init__(self, lang='en', valueOf_=None):
        self.original_tagname_ = None
        super(OrganizationType13, self).__init__(lang, valueOf_, )
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if OrganizationType13.subclass:
            return OrganizationType13.subclass(*args_, **kwargs_)
        else:
            return OrganizationType13(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(OrganizationType13, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='OrganizationType13', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OrganizationType13')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='OrganizationType13', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='OrganizationType13'):
        super(OrganizationType13, self).exportAttributes(outfile, level, already_processed, namespace_, name_='OrganizationType13')
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='OrganizationType13', fromsubclass_=False, pretty_print=True):
        super(OrganizationType13, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='OrganizationType13'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(OrganizationType13, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(OrganizationType13, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(OrganizationType13, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class OrganizationType13


class DescriptionType14(localizedString):
    subclass = None
    superclass = localizedString
    def __init__(self, lang='en', valueOf_=None):
        self.original_tagname_ = None
        super(DescriptionType14, self).__init__(lang, valueOf_, )
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if DescriptionType14.subclass:
            return DescriptionType14.subclass(*args_, **kwargs_)
        else:
            return DescriptionType14(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(DescriptionType14, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='DescriptionType14', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DescriptionType14')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='DescriptionType14', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='DescriptionType14'):
        super(DescriptionType14, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DescriptionType14')
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='DescriptionType14', fromsubclass_=False, pretty_print=True):
        super(DescriptionType14, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='DescriptionType14'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DescriptionType14, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DescriptionType14, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DescriptionType14, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DescriptionType14


class RelationshipType(GeneratedsSuper):
    """The ProductReference refers to the unique ProductID of the product
    that is to which another product will be related.The
    RelationType attribute defines how the two products are
    related.RelatesToProductReference refers to the unique ProductID
    of the product to which the ProductReference attribute value
    relates."""
    subclass = None
    superclass = None
    def __init__(self, RelationType=None, RelatesToProductReference=None, ProductReference=None, FullProductName=None):
        self.original_tagname_ = None
        self.RelationType = _cast(None, RelationType)
        self.RelatesToProductReference = _cast(None, RelatesToProductReference)
        self.ProductReference = _cast(None, ProductReference)
        if FullProductName is None:
            self.FullProductName = []
        else:
            self.FullProductName = FullProductName
    def factory(*args_, **kwargs_):
        if RelationshipType.subclass:
            return RelationshipType.subclass(*args_, **kwargs_)
        else:
            return RelationshipType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_FullProductName(self): return self.FullProductName
    def set_FullProductName(self, FullProductName): self.FullProductName = FullProductName
    def add_FullProductName(self, value): self.FullProductName.append(value)
    def insert_FullProductName_at(self, index, value): self.FullProductName.insert(index, value)
    def replace_FullProductName_at(self, index, value): self.FullProductName[index] = value
    def get_RelationType(self): return self.RelationType
    def set_RelationType(self, RelationType): self.RelationType = RelationType
    def get_RelatesToProductReference(self): return self.RelatesToProductReference
    def set_RelatesToProductReference(self, RelatesToProductReference): self.RelatesToProductReference = RelatesToProductReference
    def get_ProductReference(self): return self.ProductReference
    def set_ProductReference(self, ProductReference): self.ProductReference = ProductReference
    def hasContent_(self):
        if (
            self.FullProductName
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='RelationshipType', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1" xmlns:prod="http://www.icasi.org/CVRF/schema/prod/1.1" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RelationshipType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='RelationshipType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='RelationshipType'):
        if self.RelationType is not None and 'RelationType' not in already_processed:
            already_processed.add('RelationType')
            outfile.write(' RelationType=%s' % (quote_attrib(self.RelationType), ))
        if self.RelatesToProductReference is not None and 'RelatesToProductReference' not in already_processed:
            already_processed.add('RelatesToProductReference')
            outfile.write(' RelatesToProductReference=%s' % (self.gds_format_string(quote_attrib(self.RelatesToProductReference).encode(ExternalEncoding), input_name='RelatesToProductReference'), ))
        if self.ProductReference is not None and 'ProductReference' not in already_processed:
            already_processed.add('ProductReference')
            outfile.write(' ProductReference=%s' % (self.gds_format_string(quote_attrib(self.ProductReference).encode(ExternalEncoding), input_name='ProductReference'), ))
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='RelationshipType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for FullProductName_ in self.FullProductName:
            FullProductName_.export(outfile, level, namespace_='prod:', name_='FullProductName', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='RelationshipType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.RelationType is not None and 'RelationType' not in already_processed:
            already_processed.add('RelationType')
            showIndent(outfile, level)
            outfile.write('RelationType=%s,\n' % (self.RelationType,))
        if self.RelatesToProductReference is not None and 'RelatesToProductReference' not in already_processed:
            already_processed.add('RelatesToProductReference')
            showIndent(outfile, level)
            outfile.write('RelatesToProductReference="%s",\n' % (self.RelatesToProductReference,))
        if self.ProductReference is not None and 'ProductReference' not in already_processed:
            already_processed.add('ProductReference')
            showIndent(outfile, level)
            outfile.write('ProductReference="%s",\n' % (self.ProductReference,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('FullProductName=[\n')
        level += 1
        for FullProductName_ in self.FullProductName:
            showIndent(outfile, level)
            outfile.write('model_.FullProductName(\n')
            FullProductName_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('RelationType', node)
        if value is not None and 'RelationType' not in already_processed:
            already_processed.add('RelationType')
            self.RelationType = value
        value = find_attr_value_('RelatesToProductReference', node)
        if value is not None and 'RelatesToProductReference' not in already_processed:
            already_processed.add('RelatesToProductReference')
            self.RelatesToProductReference = value
            self.RelatesToProductReference = ' '.join(self.RelatesToProductReference.split())
        value = find_attr_value_('ProductReference', node)
        if value is not None and 'ProductReference' not in already_processed:
            already_processed.add('ProductReference')
            self.ProductReference = value
            self.ProductReference = ' '.join(self.ProductReference.split())
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FullProductName':
            obj_ = FullProductName.factory()
            obj_.build(child_)
            self.FullProductName.append(obj_)
            obj_.original_tagname_ = 'FullProductName'
# end class RelationshipType


class ProductGroupsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Group=None):
        self.original_tagname_ = None
        if Group is None:
            self.Group = []
        else:
            self.Group = Group
    def factory(*args_, **kwargs_):
        if ProductGroupsType.subclass:
            return ProductGroupsType.subclass(*args_, **kwargs_)
        else:
            return ProductGroupsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Group(self): return self.Group
    def set_Group(self, Group): self.Group = Group
    def add_Group(self, value): self.Group.append(value)
    def insert_Group_at(self, index, value): self.Group.insert(index, value)
    def replace_Group_at(self, index, value): self.Group[index] = value
    def hasContent_(self):
        if (
            self.Group
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='ProductGroupsType', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProductGroupsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='ProductGroupsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='ProductGroupsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='ProductGroupsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Group_ in self.Group:
            Group_.export(outfile, level, namespace_, name_='Group', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ProductGroupsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Group=[\n')
        level += 1
        for Group_ in self.Group:
            showIndent(outfile, level)
            outfile.write('model_.GroupType(\n')
            Group_.exportLiteral(outfile, level, name_='GroupType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Group':
            obj_ = GroupType.factory()
            obj_.build(child_)
            self.Group.append(obj_)
            obj_.original_tagname_ = 'Group'
# end class ProductGroupsType


class GroupType(GeneratedsSuper):
    """The unique identifier used to reference this group."""
    subclass = None
    superclass = None
    def __init__(self, GroupID=None, Description=None, ProductID=None):
        self.original_tagname_ = None
        self.GroupID = _cast(None, GroupID)
        self.Description = Description
        if ProductID is None:
            self.ProductID = []
        else:
            self.ProductID = ProductID
    def factory(*args_, **kwargs_):
        if GroupType.subclass:
            return GroupType.subclass(*args_, **kwargs_)
        else:
            return GroupType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_ProductID(self): return self.ProductID
    def set_ProductID(self, ProductID): self.ProductID = ProductID
    def add_ProductID(self, value): self.ProductID.append(value)
    def insert_ProductID_at(self, index, value): self.ProductID.insert(index, value)
    def replace_ProductID_at(self, index, value): self.ProductID[index] = value
    def get_GroupID(self): return self.GroupID
    def set_GroupID(self, GroupID): self.GroupID = GroupID
    def hasContent_(self):
        if (
            self.Description is not None or
            self.ProductID
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='GroupType', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GroupType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='GroupType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='GroupType'):
        if self.GroupID is not None and 'GroupID' not in already_processed:
            already_processed.add('GroupID')
            outfile.write(' GroupID=%s' % (self.gds_format_string(quote_attrib(self.GroupID).encode(ExternalEncoding), input_name='GroupID'), ))
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='GroupType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Description is not None:
            self.Description.export(outfile, level, namespace_, name_='Description', pretty_print=pretty_print)
        for ProductID_ in self.ProductID:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sProductID>%s</%sProductID>%s' % (namespace_, self.gds_format_string(quote_xml(ProductID_).encode(ExternalEncoding), input_name='ProductID'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='GroupType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.GroupID is not None and 'GroupID' not in already_processed:
            already_processed.add('GroupID')
            showIndent(outfile, level)
            outfile.write('GroupID="%s",\n' % (self.GroupID,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('Description=model_.DescriptionType15(\n')
            self.Description.exportLiteral(outfile, level, name_='Description')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('ProductID=[\n')
        level += 1
        for ProductID_ in self.ProductID:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(ProductID_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('GroupID', node)
        if value is not None and 'GroupID' not in already_processed:
            already_processed.add('GroupID')
            self.GroupID = value
            self.GroupID = ' '.join(self.GroupID.split())
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Description':
            obj_ = DescriptionType15.factory()
            obj_.build(child_)
            self.Description = obj_
            obj_.original_tagname_ = 'Description'
        elif nodeName_ == 'ProductID':
            ProductID_ = child_.text
            ProductID_ = re_.sub(String_cleanup_pat_, " ", ProductID_).strip()
            ProductID_ = self.gds_validate_string(ProductID_, node, 'ProductID')
            self.ProductID.append(ProductID_)
# end class GroupType


class DescriptionType15(localizedString):
    subclass = None
    superclass = localizedString
    def __init__(self, lang='en', valueOf_=None):
        self.original_tagname_ = None
        super(DescriptionType15, self).__init__(lang, valueOf_, )
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if DescriptionType15.subclass:
            return DescriptionType15.subclass(*args_, **kwargs_)
        else:
            return DescriptionType15(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(DescriptionType15, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='DescriptionType15', namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DescriptionType15')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='DescriptionType15', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='DescriptionType15'):
        super(DescriptionType15, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DescriptionType15')
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='DescriptionType15', fromsubclass_=False, pretty_print=True):
        super(DescriptionType15, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='DescriptionType15'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DescriptionType15, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DescriptionType15, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DescriptionType15, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DescriptionType15


class checkReferenceType(checkSearchType):
    """Data type for the check element, a checking system specification
    URI, string content, and an optional external file reference.
    The checking system specification should be the URI for a
    particular version of OVAL or a related system testing language,
    and the content will be an identifier of a test written in that
    language. The external file reference could be used to point to
    the file in which the content test identifier is defined."""
    subclass = None
    superclass = checkSearchType
    def __init__(self, system=None, name=None, href=None):
        self.original_tagname_ = None
        super(checkReferenceType, self).__init__(system, name, )
        self.href = _cast(None, href)
    def factory(*args_, **kwargs_):
        if checkReferenceType.subclass:
            return checkReferenceType.subclass(*args_, **kwargs_)
        else:
            return checkReferenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def hasContent_(self):
        if (
            super(checkReferenceType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cvrf:', name_='checkReferenceType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='checkReferenceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cvrf:', name_='checkReferenceType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cvrf:', name_='checkReferenceType'):
        super(checkReferenceType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='checkReferenceType')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (quote_attrib(self.href), ))
    def exportChildren(self, outfile, level, namespace_='cvrf:', name_='checkReferenceType', fromsubclass_=False, pretty_print=True):
        super(checkReferenceType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='checkReferenceType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            showIndent(outfile, level)
            outfile.write('href=%s,\n' % (self.href,))
        super(checkReferenceType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(checkReferenceType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        super(checkReferenceType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(checkReferenceType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class checkReferenceType


GDSClassesMapping = {
    'Threats': ThreatsType,
    'Branch': BranchType,
    'Generator': GeneratorType,
    'Title': TitleType,
    'Acknowledgments': AcknowledgmentsType10,
    'collateral-damage-potential': collateralDamagePotentialType,
    'Threat': ThreatType,
    'control-mapping': controlMappingType,
    'ContactDetails': ContactDetailsType,
    'fact-ref': FactRefType,
    'availability-impact': ciaType,
    'Identification': IdentificationType,
    'Relationship': RelationshipType,
    'integrity-requirement': ciaRequirementType,
    'ProductStatuses': ProductStatusesType,
    'integrity-impact': ciaType,
    'any': SimpleLiteral,
    'confidentiality-impact': ciaType,
    'Engine': EngineType,
    'Involvement': InvolvementType,
    'assessment-check': checkReferenceType,
    'Remediations': RemediationsType,
    'title': TextType,
    'DocumentTracking': DocumentTrackingType,
    'DocumentTitle': DocumentTitleType,
    'DocumentNotes': DocumentNotesType,
    'platform': PlatformType,
    'authentication': authenticationType,
    'temporal_metrics': temporalMetricsType,
    'DocumentReferences': DocumentReferencesType,
    'Remediation': RemediationType,
    'assessment-method': identifyableAssessmentMethodType,
    'confidentiality-requirement': ciaRequirementType,
    'ScoreSet': ScoreSetType,
    'DocumentPublisher': DocumentPublisherType,
    'Status': StatusType,
    'Involvements': InvolvementsType,
    'CVSSScoreSets': CVSSScoreSetsType,
    'Name': NameType12,
    'Entitlement': EntitlementType,
    'remediation-level': remediationLevelType,
    'Group': GroupType,
    'target-distribution': targetDistributionType,
    'Notes': NotesType,
    'DocumentType': DocumentTypeType,
    'AggregateSeverity': AggregateSeverityType,
    'Note': NoteType4,
    'mapping': mappingInstanceType,
    'Alias': AliasType,
    'environmental_metrics': environmentalMetricsType,
    'platform-configuration': PlatformBaseType,
    'Organization': OrganizationType13,
    'CWE': CWEType,
    'ID': IDType,
    'platform-specification': platformSpecificationType,
    'DocumentDistribution': DocumentDistributionType,
    'remark': TextType,
    'access-vector': accessVectorType,
    'Acknowledgment': AcknowledgmentType11,
    'control-mappings': controlMappingsType,
    'Reference': ReferenceType8,
    'report-confidence': confidenceType,
    'Revision': RevisionType,
    'access-complexity': accessComplexityType,
    'availability-requirement': ciaRequirementType,
    'Description': DescriptionType15,
    'IssuingAuthority': IssuingAuthorityType,
    'References': ReferencesType,
    'base_metrics': baseMetricsType,
    'ProductGroups': ProductGroupsType,
    'RevisionHistory': RevisionHistoryType,
    'logical-test': LogicalTestType,
    'exploitability': exploitabilityType,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print USAGE_TEXT
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'cvrfdoc'
        rootClass = cvrfdoc
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'cvrfdoc'
        rootClass = cvrfdoc
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    from StringIO import StringIO
    doc = parsexml_(StringIO(inString))
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'cvrfdoc'
        rootClass = cvrfdoc
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='xmlns:cvrf="http://www.icasi.org/CVRF/schema/cvrf/1.1"')
    return rootObj


def parseLiteral(inFileName, silence=False):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'cvrfdoc'
        rootClass = cvrfdoc
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from cvrf import *\n\n')
        sys.stdout.write('import cvrf as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "AcknowledgmentType",
    "AcknowledgmentType11",
    "AcknowledgmentsType",
    "AcknowledgmentsType10",
    "AggregateSeverityType",
    "AliasType",
    "BranchType",
    "CVSSScoreSetsType",
    "CWEType",
    "ContactDetailsType",
    "DescriptionType",
    "DescriptionType1",
    "DescriptionType14",
    "DescriptionType15",
    "DescriptionType2",
    "DescriptionType5",
    "DescriptionType6",
    "DescriptionType7",
    "DescriptionType9",
    "DocumentDistributionType",
    "DocumentNotesType",
    "DocumentPublisherType",
    "DocumentReferencesType",
    "DocumentTitleType",
    "DocumentTrackingType",
    "DocumentTypeType",
    "EngineType",
    "EntitlementType",
    "FactRefType",
    "FullProductName",
    "GeneratorType",
    "GroupType",
    "IDType",
    "IDType3",
    "IdentificationType",
    "InvolvementType",
    "InvolvementsType",
    "IssuingAuthorityType",
    "LogicalTestType",
    "NameType",
    "NameType12",
    "NoteType",
    "NoteType4",
    "NotesType",
    "OrganizationType",
    "OrganizationType13",
    "PlatformBaseType",
    "PlatformType",
    "ProductGroupsType",
    "ProductStatusesType",
    "ProductTree",
    "ReferenceType",
    "ReferenceType8",
    "ReferencesType",
    "RelationshipType",
    "RemediationType",
    "RemediationsType",
    "RevisionHistoryType",
    "RevisionType",
    "ScoreSetType",
    "SimpleLiteral",
    "StatusType",
    "TextType",
    "ThreatType",
    "ThreatsType",
    "TitleType",
    "Vulnerability",
    "accessComplexityType",
    "accessVectorType",
    "assessmentMethodType",
    "authenticationType",
    "baseMetricsType",
    "checkReferenceType",
    "checkSearchType",
    "ciaRequirementType",
    "ciaType",
    "collateralDamagePotentialType",
    "confidenceType",
    "contributor",
    "controlMappingType",
    "controlMappingsType",
    "coverage",
    "creator",
    "cvrfdoc",
    "cvssImpactBaseType",
    "cvssImpactEnvironmentalType",
    "cvssImpactTemporalType",
    "cvssImpactType",
    "cvssType",
    "date",
    "description",
    "elementContainer",
    "environmentalMetricsType",
    "exploitabilityType",
    "format",
    "identifier",
    "identifyableAssessmentMethodType",
    "language",
    "localizedNormalizedString",
    "localizedString",
    "mappingInstanceType",
    "metricsType",
    "platformSpecificationType",
    "publisher",
    "relation",
    "remediationLevelType",
    "rights",
    "searchableCpeReferencesType",
    "source",
    "subject",
    "targetDistributionType",
    "temporalMetricsType",
    "title",
    "type_"
]
